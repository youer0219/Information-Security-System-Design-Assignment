### 4-6 学时实践要求（30 分）

1. 参考相关内容，在 Ubuntu或openEuler中（推荐 openEuler）中使用OpenSSL库编程实现调用SM2（加密解密，签名验签），SM3（摘要计算，HMAC 计算），SM4（加密解密）算法，使用Markdown记录详细记录实践过程，每完成一项git commit 一次。（5'）
- SM3 hash实现
    - 过程与验证
        ```
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm3# nano sm3_hash.c
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm3# gcc sm3_hash.c -o sm3_hash -lssl -lcrypto
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm3# ./sm3_hash "20221414xlm"
        SM3 hash: 5fa790c6e893e4e724edea87d4c58c3426ba5487c5314a15d9d8c990364920e5
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm3# git add .
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm3# git commit -m "shiyan1-2/Task01:finish SM3 MAC"
        [master d854781] shiyan1-2/Task01:finish SM3 MAC
        2 files changed, 51 insertions(+)
        create mode 100755 shiyan1-2/task01/test_sm3/sm3_hash
        create mode 100644 shiyan1-2/task01/test_sm3/sm3_hash.c
        ```
    - 具体代码
        ```
        #include <stdio.h>
        #include <openssl/evp.h>
        #include <openssl/err.h>
        #include <string.h>

        void sm3_hash(const char* data) {
            EVP_MD_CTX* mdctx;
            const EVP_MD* md;
            unsigned char md_value[EVP_MAX_MD_SIZE];
            unsigned int md_len;

            // 使用SM3哈希算法
            OpenSSL_add_all_digests();
            md = EVP_get_digestbyname("sm3");
            if (md == NULL) {
                printf("Unknown message digest sm3\n");
                return;
            }

            // 创建并初始化散列上下文
            mdctx = EVP_MD_CTX_new();
            EVP_DigestInit_ex(mdctx, md, NULL);

            // 传递数据给散列函数
            EVP_DigestUpdate(mdctx, data, strlen(data));

            // 获取散列值
            EVP_DigestFinal_ex(mdctx, md_value, &md_len);

            // 打印散列值
            printf("SM3 hash: ");
            for (int i = 0; i < md_len; i++) {
                printf("%02x", md_value[i]);
            }
            printf("\n");

            // 清理
            EVP_MD_CTX_free(mdctx);
            EVP_cleanup();
        }

        int main(int argc, char* argv[]) {
            if (argc < 2) {
                printf("Usage: %s <string_to_hash>\n", argv[0]);
                return 1;
            }

            // 将命令行参数传递给sm3_hash函数
            sm3_hash(argv[1]);
            return 0;
        }

        ```
- SM3 HAMC实现
    - 过程与验证
        ```
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm3# ls
        sm3_hash  sm3_hash.c
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm3# nano sm3_hmac
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm3# gcc -o sm3_hmac sm3_hmac.c -lcrypto
        cc1: fatal error: sm3_hmac.c: No such file or directory
        compilation terminated.
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm3# mv sm3_hmac sm3_hmac.c
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm3# gcc -o sm3_hmac sm3_hmac.c -lcrypto
        sm3_hmac.c: In function ‘main’:
        sm3_hmac.c:21:5: warning: ‘HMAC_CTX_new’ is deprecated: Since OpenSSL 3.0 [-Wdeprecated-declarations]
        21 |     ctx = HMAC_CTX_new();
            |     ^~~
        In file included from sm3_hmac.c:3:
        /usr/include/openssl/hmac.h:33:33: note: declared here
        33 | OSSL_DEPRECATEDIN_3_0 HMAC_CTX *HMAC_CTX_new(void);
            |                                 ^~~~~~~~~~~~
        sm3_hmac.c:27:5: warning: ‘HMAC_Init_ex’ is deprecated: Since OpenSSL 3.0 [-Wdeprecated-declarations]
        27 |     if (HMAC_Init_ex(ctx, key, key_len, md, NULL) != 1) {
            |     ^~
        In file included from sm3_hmac.c:3:
        /usr/include/openssl/hmac.h:43:27: note: declared here
        43 | OSSL_DEPRECATEDIN_3_0 int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,
            |                           ^~~~~~~~~~~~
        sm3_hmac.c:33:5: warning: ‘HMAC_Update’ is deprecated: Since OpenSSL 3.0 [-Wdeprecated-declarations]
        33 |     if (HMAC_Update(ctx, data, data_len) != 1) {
            |     ^~
        In file included from sm3_hmac.c:3:
        /usr/include/openssl/hmac.h:45:27: note: declared here
        45 | OSSL_DEPRECATEDIN_3_0 int HMAC_Update(HMAC_CTX *ctx, const unsigned char *data,
            |                           ^~~~~~~~~~~
        sm3_hmac.c:41:5: warning: ‘HMAC_Final’ is deprecated: Since OpenSSL 3.0 [-Wdeprecated-declarations]
        41 |     if (HMAC_Final(ctx, hmac_value, &hmac_len) != 1) {
            |     ^~
        In file included from sm3_hmac.c:3:
        /usr/include/openssl/hmac.h:47:27: note: declared here
        47 | OSSL_DEPRECATEDIN_3_0 int HMAC_Final(HMAC_CTX *ctx, unsigned char *md,
            |                           ^~~~~~~~~~
        sm3_hmac.c:47:5: warning: ‘HMAC_CTX_free’ is deprecated: Since OpenSSL 3.0 [-Wdeprecated-declarations]
        47 |     HMAC_CTX_free(ctx);
            |     ^~~~~~~~~~~~~
        In file included from sm3_hmac.c:3:
        /usr/include/openssl/hmac.h:35:28: note: declared here
        35 | OSSL_DEPRECATEDIN_3_0 void HMAC_CTX_free(HMAC_CTX *ctx);
            |                            ^~~~~~~~~~~~~
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm3# nano sm3_hmac
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm3# nano sm3_hmac.c
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm3# gcc -o sm3_hmac sm3_hmac.c -lcrypto
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm3# ./sm3_hmac_updated "mysecretkey" "my message"
        -bash: ./sm3_hmac_updated: No such file or directory
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm3# ./sm3_hmac "mysecretkey" "my message"
        HMAC: c1d7bc47622831a4b0882391ebb444550e16b517800a03b3af2427fb5b001567
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm3# ./sm3_hmac "newsecretkey" "my message"
        HMAC: 7d9285231fe7a97fc7d03c1f72f31ec5e984ae2572bc1c4984818232c8a404ff
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm3# git add .
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm3# git commit -m "finish sm3 HMAC"
        [master b8cfa84] finish sm3 HMAC
        2 files changed, 64 insertions(+)
        create mode 100755 shiyan1-2/task01/test_sm3/sm3_hmac
        create mode 100644 shiyan1-2/task01/test_sm3/sm3_hmac.c
        ```
    - 具体代码
        ```
        #include <stdio.h>
        #include <openssl/evp.h>
        #include <string.h>

        int main(int argc, char *argv[]) {
            if (argc != 3) {
                fprintf(stderr, "Usage: %s <key> <data>\n", argv[0]);
                return 1;
            }

            unsigned char *key = (unsigned char *)argv[1];
            unsigned char *data = (unsigned char *)argv[2];
            size_t key_len = strlen((char *)key);
            size_t data_len = strlen((char *)data);

            // 创建和初始化EVP_MAC_CTX和EVP_MAC变量
            EVP_MAC_CTX *ctx;
            EVP_MAC *mac;
            OSSL_PARAM params[2];
            unsigned char *out;
            size_t out_len;

            // 设置算法类型
            mac = EVP_MAC_fetch(NULL, "HMAC", NULL);
            ctx = EVP_MAC_CTX_new(mac);

            // 设置参数：摘要算法
            params[0] = OSSL_PARAM_construct_utf8_string("digest", "SM3", 0);
            params[1] = OSSL_PARAM_construct_end();

            if (!EVP_MAC_init(ctx, key, key_len, params)) {
                fprintf(stderr, "Failed to initialize HMAC\n");
                return 1;
            }

            if (!EVP_MAC_update(ctx, data, data_len)) {
                fprintf(stderr, "Failed to update HMAC\n");
                return 1;
            }

            // 计算HMAC长度
            EVP_MAC_final(ctx, NULL, &out_len, 0);
            out = malloc(out_len);

            if (!EVP_MAC_final(ctx, out, &out_len, out_len)) {
                fprintf(stderr, "Failed to finalize HMAC\n");
                return 1;
            }

            // 打印结果
            printf("HMAC: ");
            for (size_t i = 0; i < out_len; i++) {
                printf("%02x", out[i]);
            }
            printf("\n");

            // 清理资源
            EVP_MAC_CTX_free(ctx);
            EVP_MAC_free(mac);
            free(out);

            return 0;
        }

        ```
- SM4 加解密
    - 过程与验证
        ```
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01# mkdir test_sm4
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01# cd test_sm4
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm4# nano sm4_encrypt.c
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm4# nano sm4_decrypt.c
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm4# ls
        sm4_decrypt.c  sm4_encrypt.c
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm4# gcc sm4_encrypt.c -o sm4_encrypt -lcrypto
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm4# gcc sm4_decrypt.c -o sm4_decrypt -lcrypto
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm4# echo "20221414xlm" > plain.txt
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm4# touch encrypted_file
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm4# rm encrypted_file
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm4# touch encrypted_file.txt
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm4# touch decrypted_file.txt
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm4# ls
        decrypted_file.txt  encrypted_file.txt  plain.txt  sm4_decrypt  sm4_decrypt.c  sm4_encrypt  sm4_encrypt.c
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm4# ./sm4_encrypt "0123456789abcdef" "1234567890abcdef" plain.txt en
        crypted_file.txt
        Encryption complete.
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm4# ./sm4_decrypt "0123456789abcdef" "1234567890abcdef" encrypted_fi
        le.txt decrypted_file.txt
        Decryption complete.
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm4# cat encrypted_file.txt
        AQ��z�b�[6l͚root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm4# cat decrypted_file.txt
        20221414xlm
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm4# git add .
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm4# git commit -m "finish SM4 encrypt & decrypt"
        [master 7e4df4d] finish SM4 encrypt & decrypt
        7 files changed, 145 insertions(+)
        create mode 100644 shiyan1-2/task01/test_sm4/decrypted_file.txt
        create mode 100644 shiyan1-2/task01/test_sm4/encrypted_file.txt
        create mode 100644 shiyan1-2/task01/test_sm4/plain.txt
        create mode 100755 shiyan1-2/task01/test_sm4/sm4_decrypt
        create mode 100644 shiyan1-2/task01/test_sm4/sm4_decrypt.c
        create mode 100755 shiyan1-2/task01/test_sm4/sm4_encrypt
        create mode 100644 shiyan1-2/task01/test_sm4/sm4_encrypt.c
        ```
    - 具体代码
        - SM4 加密程序
            ```
            #include <openssl/evp.h>
            #include <stdio.h>
            #include <stdlib.h>

            void handleErrors(void) {
                fprintf(stderr, "An error occurred.\n");
                exit(1);
            }

            int main(int argc, char *argv[]) {
                if (argc != 5) {
                    fprintf(stderr, "Usage: %s <key> <iv> <input file> <output file>\n", argv[0]);
                    return 1;
                }

                char *key = argv[1];
                char *iv = argv[2];
                char *input_file = argv[3];
                char *output_file = argv[4];

                FILE *f_input, *f_output;
                unsigned char buffer[1024];
                unsigned char ciphertext[1024 + EVP_MAX_BLOCK_LENGTH];
                int bytes_read, ciphertext_len;

                EVP_CIPHER_CTX *ctx;

                // Initialise the library
                if(!OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL))
                    handleErrors();

                // Create and initialise the context
                if(!(ctx = EVP_CIPHER_CTX_new())) 
                    handleErrors();

                // Initialise the encryption operation.
                if(1 != EVP_EncryptInit_ex(ctx, EVP_sm4_cbc(), NULL, (unsigned char*)key, (unsigned char*)iv))
                    handleErrors();

                // Open files
                if(!(f_input = fopen(input_file, "rb"))) {
                    fprintf(stderr, "Could not open %s for reading\n", input_file);
                    return 1;
                }

                if(!(f_output = fopen(output_file, "wb"))) {
                    fprintf(stderr, "Could not open %s for writing\n", output_file);
                    return 1;
                }

                // Provide the message to be encrypted
                while((bytes_read = fread(buffer, 1, 1024, f_input)) > 0) {
                    if(1 != EVP_EncryptUpdate(ctx, ciphertext, &ciphertext_len, buffer, bytes_read))
                        handleErrors();
                    fwrite(ciphertext, 1, ciphertext_len, f_output);
                }

                // Finalise the encryption
                if(1 != EVP_EncryptFinal_ex(ctx, ciphertext + ciphertext_len, &ciphertext_len))
                    handleErrors();
                fwrite(ciphertext, 1, ciphertext_len, f_output);

                // Clean up
                EVP_CIPHER_CTX_free(ctx);
                fclose(f_input);
                fclose(f_output);

                printf("Encryption complete.\n");

                return 0;
            }

            ```
        - SM4 解密程序
            ```
            #include <openssl/evp.h>
            #include <stdio.h>
            #include <stdlib.h>

            void handleErrors(void) {
                fprintf(stderr, "An error occurred.\n");
                exit(1);
            }

            int main(int argc, char *argv[]) {
                if (argc != 5) {
                    fprintf(stderr, "Usage: %s <key> <iv> <input file> <output file>\n", argv[0]);
                    return 1;
                }

                char *key = argv[1];
                char *iv = argv[2];
                char *input_file = argv[3];
                char *output_file = argv[4];

                FILE *f_input, *f_output;
                unsigned char buffer[1024];
                unsigned char plaintext[1024 + EVP_MAX_BLOCK_LENGTH];
                int bytes_read, plaintext_len;

                EVP_CIPHER_CTX *ctx;

                // Initialise the library
                if(!OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL))
                    handleErrors();

                // Create and initialise the context
                if(!(ctx = EVP_CIPHER_CTX_new())) 
                    handleErrors();

                // Initialise the decryption operation.
                if(1 != EVP_DecryptInit_ex(ctx, EVP_sm4_cbc(), NULL, (unsigned char*)key, (unsigned char*)iv))
                    handleErrors();

                // Open files
                if(!(f_input = fopen(input_file, "rb"))) {
                    fprintf(stderr, "Could not open %s for reading\n", input_file);
                    return 1;
                }

                if(!(f_output = fopen(output_file, "wb"))) {
                    fprintf(stderr, "Could not open %s for writing\n", output_file);
                    return 1;
                }

                // Provide the message to be decrypted
                while((bytes_read = fread(buffer, 1, 1024, f_input)) > 0) {
                    if(1 != EVP_DecryptUpdate(ctx, plaintext, &plaintext_len, buffer, bytes_read))
                        handleErrors();
                    fwrite(plaintext, 1, plaintext_len, f_output);
                }

                // Finalise the decryption
                if(1 != EVP_DecryptFinal_ex(ctx, plaintext + plaintext_len, &plaintext_len))
                    handleErrors();
                fwrite(plaintext, 1, plaintext_len, f_output);

                // Clean up
                EVP_CIPHER_CTX_free(ctx);
                fclose(f_input);
                fclose(f_output);

                printf("Decryption complete.\n");

                return 0;
            }

            ``` 
- SM2 加解密、签名与验证
    - SM2加解密
        - 过程和验证
            ```
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# ls
            decrypted_file.txt  plain.txt    sm2_decrypt.c  sm2_encrypt.c    sm2_public.pem
            encrypted_file.txt  sm2_decrypt  sm2_encrypt    sm2_private.pem
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# rm sm2_encrypt.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# nano sm2_encrypt.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# gcc sm2_encrypt.c -o sm2_encrypt -lcrypto
            sm2_encrypt.c: In function ‘main’:
            sm2_encrypt.c:82:9: warning: implicit declaration of function ‘EVP_PKEY_encrypt_final’; did you mean ‘EVP_PKEY_encrypt_init’? [-Wimplicit-function-declaration]
            82 |     if (EVP_PKEY_encrypt_final(ctx, ciphertext, &ciphertext_len) <= 0)
                |         ^~~~~~~~~~~~~~~~~~~~~~
                |         EVP_PKEY_encrypt_init
            /usr/bin/ld: /tmp/ccq6e5QM.o: in function `main':
            sm2_encrypt.c:(.text+0x3fa): undefined reference to `EVP_PKEY_encrypt_final'
            collect2: error: ld returned 1 exit status
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# rm sm2_encrypt.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# nano sm2_encrypt.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# gcc sm2_encrypt.c -o sm2_encrypt -lcrypto
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# ./sm2_encrypt sm2_public.pem plain.txt encrypted_file.txt
            Encryption complete.
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# rm sm2_decrypt.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# nano sm2_decrypt.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# gcc sm2_decrypt.c -o sm2_decrypt -lcrypto
            sm2_decrypt.c: In function ‘main’:
            sm2_decrypt.c:65:37: warning: passing argument 3 of ‘EVP_PKEY_decrypt’ from incompatible pointer type [-Wincompatible-pointer-types]
            65 |     if (EVP_PKEY_decrypt(ctx, NULL, &plaintext_len, buffer, sizeof(buffer)) <= 0)
                |                                     ^~~~~~~~~~~~~~
                |                                     |
                |                                     int *
            In file included from sm2_decrypt.c:1:
            /usr/include/openssl/evp.h:1914:50: note: expected ‘size_t *’ {aka ‘long unsigned int *’} but argument is of type ‘int ’
            1914 |                      unsigned char *out, size_t *outlen,
                |                                          ~~~~~~~~^~~~~~
            sm2_decrypt.c:75:46: warning: passing argument 3 of ‘EVP_PKEY_decrypt’ from incompatible pointer type [-Wincompatible-pointer-types]
            75 |         if (EVP_PKEY_decrypt(ctx, plaintext, &plaintext_len, buffer, bytes_read) <= 0)
                |                                              ^~~~~~~~~~~~~~
                |                                              |
                |                                              int *
            In file included from sm2_decrypt.c:1:
            /usr/include/openssl/evp.h:1914:50: note: expected ‘size_t *’ {aka ‘long unsigned int *’} but argument is of type ‘int ’
            1914 |                      unsigned char *out, size_t *outlen,
                |                                          ~~~~~~~~^~~~~~
            sm2_decrypt.c:81:9: warning: implicit declaration of function ‘EVP_PKEY_decrypt_final’; did you mean ‘EVP_PKEY_decrypt_init’? [-Wimplicit-function-declaration]
            81 |     if (EVP_PKEY_decrypt_final(ctx, plaintext, &plaintext_len) <= 0)
                |         ^~~~~~~~~~~~~~~~~~~~~~
                |         EVP_PKEY_decrypt_init
            /usr/bin/ld: /tmp/ccxLtmHg.o: in function `main':
            sm2_decrypt.c:(.text+0x3fd): undefined reference to `EVP_PKEY_decrypt_final'
            collect2: error: ld returned 1 exit status
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# rm sm2_decrypt.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# nano sm2_decrypt.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# gcc sm2_decrypt.c -o sm2_decrypt -lcrypto
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# ls
            decrypted_file.txt  plain.txt    sm2_decrypt.c  sm2_encrypt.c    sm2_public.pem
            encrypted_file.txt  sm2_decrypt  sm2_encrypt    sm2_private.pem
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# ./sm2_decrypt privkey.pem encrypted_file.txt decrypted_file.txt
            Unable to open private key file privkey.pem
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# ./sm2_decrypt sm2_private.pem encrypted_file.txt decrypted_file.
            txt
            An error occurred.
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# rm sm2_decrypt.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# nano sm2_decrypt.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# gcc sm2_decrypt.c -o sm2_decrypt -lcrypto
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# ./sm2_decrypt sm2_private.pem encrypted_file.txt decrypted_file.txt
            OpenSSL error: error:0680007B:asn1 encoding routines::header too long
            OpenSSL error: error:06800066:asn1 encoding routines::bad object header
            OpenSSL error: error:0688010A:asn1 encoding routines::nested asn1 error
            OpenSSL error: error:1A800068:SM2 routines::reason(104)
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# ls
            decrypted_file.txt  plain.txt    sm2_decrypt.c  sm2_encrypt.c    sm2_public.pem
            encrypted_file.txt  sm2_decrypt  sm2_encrypt    sm2_private.pem
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# mv decrypted_file.txt decrypted_file.bin
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# mv encrypted_file.txt encrypted_file.bin
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# ./sm2_encrypt sm2_public.pem plain.txt encrypted_file.bin
            Encryption complete.
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# ./sm2_decrypt sm2_private.pem encrypted_file.bin decrypted_file.
            bin
            OpenSSL error: error:0680007B:asn1 encoding routines::header too long
            OpenSSL error: error:06800066:asn1 encoding routines::bad object header
            OpenSSL error: error:0688010A:asn1 encoding routines::nested asn1 error
            OpenSSL error: error:1A800068:SM2 routines::reason(104)
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# rm encrypted_file.bin
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# rm decrypted_file.bin
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# touch encrypted_file.bin
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# touch decrypted_file.bin
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# ./sm2_encrypt sm2_public.pem plain.txt encrypted_file.bin
            Encryption complete.
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# ./sm2_decrypt sm2_private.pem encrypted_file.bin decrypted_file.bin
            OpenSSL error: error:068000A8:asn1 encoding routines::wrong tag
            OpenSSL error: error:0688010A:asn1 encoding routines::nested asn1 error
            OpenSSL error: error:1A800068:SM2 routines::reason(104)
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# openssl ec -in sm2_private.pem -text -noout
            read EC key
            Private-Key: (256 bit)
            priv:
                37:54:56:d4:3d:a4:00:7f:dc:15:3d:0c:fc:e5:88:
                db:dc:d8:49:1f:56:76:19:d2:ca:16:3a:06:78:98:
                78:95
            pub:
                04:c6:19:31:a2:7c:eb:5a:62:e6:9f:0c:f8:58:47:
                72:eb:9c:c7:0e:a0:0e:a4:f4:43:19:16:ad:77:46:
                37:8a:d2:43:01:a6:6a:0b:40:01:70:d1:4e:42:55:
                54:d8:19:a9:b3:e2:23:55:26:7a:2a:d3:98:7d:0f:
                94:85:c4:84:ec
            ASN1 OID: SM2
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# openssl ec -in sm2_public.pem -pubin -text -noout
            read EC key
            Public-Key: (256 bit)
            pub:
                04:c6:19:31:a2:7c:eb:5a:62:e6:9f:0c:f8:58:47:
                72:eb:9c:c7:0e:a0:0e:a4:f4:43:19:16:ad:77:46:
                37:8a:d2:43:01:a6:6a:0b:40:01:70:d1:4e:42:55:
                54:d8:19:a9:b3:e2:23:55:26:7a:2a:d3:98:7d:0f:
                94:85:c4:84:ec
            ASN1 OID: SM2
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# openssl pkeyutl -decrypt -in encrypted_file.bin -out decrypted_file.bin -inkey sm2_private.pem -pkeyopt ec_scheme:sm2
            pkeyutl: Can't set parameter "ec_scheme:sm2":
            803BC4A8AD7F0000:error:03000093:digital envelope routines:default_fixup_args:command not supported:../crypto/evp/ctrl_params_translate.c:580:[action:2, state:4] name=ec_scheme, value=sm2
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# openssl sm2 -decrypt -in encrypted_file.bin -out decrypted_file.bin -inkey sm2_private.pem
            Invalid command 'sm2'; type "help" for a list.
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# openssl pkeyutl -decrypt -in encrypted_file.bin -out decrypted_file.bin -inkey sm2_private.pem -pkeyopt ec_scheme:sm2
            pkeyutl: Can't set parameter "ec_scheme:sm2":
            80FB331A8E7F0000:error:03000093:digital envelope routines:default_fixup_args:command not supported:../crypto/evp/ctrl_params_translate.c:580:[action:2, state:4] name=ec_scheme, value=sm2
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# openssl version
            OpenSSL 3.0.2 15 Mar 2022 (Library: OpenSSL 3.0.2 15 Mar 2022)
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# openssl pkeyutl -decrypt -in encrypted_file.bin -out decrypted_file.bin -inkey sm2_private.pem
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# ls
            decrypted_file.bin  plain.txt    sm2_decrypt.c  sm2_encrypt.c    sm2_public.pem
            encrypted_file.bin  sm2_decrypt  sm2_encrypt    sm2_private.pem
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# cat decrypted_file.bin
            20221414xlm
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# ./sm2_decrypt sm2_private.pem encrypted_file.bin decrypted_file.bin
            OpenSSL error: error:068000A8:asn1 encoding routines::wrong tag
            OpenSSL error: error:0688010A:asn1 encoding routines::nested asn1 error
            OpenSSL error: error:1A800068:SM2 routines::reason(104)
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# nano sm2_decrypt.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# gcc sm2_decrypt.c -o sm2_decrypt -lcrypto
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# ./sm2_decrypt sm2_private.pem encrypted_file.bin decrypted_file.bin
            OpenSSL error: error:068000A8:asn1 encoding routines::wrong tag
            OpenSSL error: error:0688010A:asn1 encoding routines::nested asn1 error
            OpenSSL error: error:1A800068:SM2 routines::reason(104)
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# ls
            decrypted_file.bin  plain.txt    sm2_decrypt.c  sm2_encrypt.c    sm2_public.pem
            encrypted_file.bin  sm2_decrypt  sm2_encrypt    sm2_private.pem
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# rm sm2_decrypt.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# nano sm2_decrypt.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# gcc -o sm2_decrypt sm2_decrypt.c -lcrypto -lssl
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# ./sm2_decrypt private_key.pem encrypted_file.bin decrypted_file.bin
            Error opening private key file: No such file or directory
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# ./sm2_decrypt sm2_private.pem encrypted_file.bin decrypted_file.
            bin
            Decryption successful.
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# cat decrypted_file.bin
            20221414xlm
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# git add .
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# git commit -m "finish sm2 encrypt & decrypt"
            [master aae0ff0] finish sm2 encrypt & decrypt
            9 files changed, 199 insertions(+)
            create mode 100644 shiyan1-2/task01/test_sm2/decrypted_file.bin
            create mode 100644 shiyan1-2/task01/test_sm2/encrypted_file.bin
            create mode 100644 shiyan1-2/task01/test_sm2/plain.txt
            create mode 100755 shiyan1-2/task01/test_sm2/sm2_decrypt
            create mode 100644 shiyan1-2/task01/test_sm2/sm2_decrypt.c
            create mode 100755 shiyan1-2/task01/test_sm2/sm2_encrypt
            create mode 100644 shiyan1-2/task01/test_sm2/sm2_encrypt.c
            create mode 100644 shiyan1-2/task01/test_sm2/sm2_private.pem
            create mode 100644 shiyan1-2/task01/test_sm2/sm2_public.pem
            ```
        - 代码
            - 加密代码
                ```
                #include <openssl/evp.h>
                #include <openssl/pem.h>
                #include <stdio.h>
                #include <stdlib.h>

                void handleErrors(void) {
                    fprintf(stderr, "An error occurred.\n");
                    exit(1);
                }

                int main(int argc, char *argv[]) {
                    if (argc != 4) {
                        fprintf(stderr, "Usage: %s <pubkey.pem> <input file> <output file>\n", argv[0]);
                        return 1;
                    }

                    char *pubkey_filename = argv[1];
                    char *input_file = argv[2];
                    char *output_file = argv[3];

                    FILE *f_input, *f_output, *f_pubkey;
                    unsigned char buffer[1024];
                    unsigned char *ciphertext;
                    size_t ciphertext_len;
                    size_t bytes_read;

                    EVP_PKEY *pubkey = NULL;
                    EVP_PKEY_CTX *ctx = NULL;

                    // Load public key
                    if (!(f_pubkey = fopen(pubkey_filename, "r"))) {
                        fprintf(stderr, "Unable to open public key file %s\n", pubkey_filename);
                        return 1;
                    }

                    if (!(pubkey = PEM_read_PUBKEY(f_pubkey, NULL, NULL, NULL))) {
                        fprintf(stderr, "Error loading public key\n");
                        fclose(f_pubkey);
                        return 1;
                    }
                    fclose(f_pubkey);

                    // Initialise the library
                    if (!OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL))
                        handleErrors();

                    // Create and initialise the context
                    if (!(ctx = EVP_PKEY_CTX_new(pubkey, NULL)))
                        handleErrors();

                    if (EVP_PKEY_encrypt_init(ctx) <= 0)
                        handleErrors();

                    // Open files
                    if (!(f_input = fopen(input_file, "rb"))) {
                        fprintf(stderr, "Could not open %s for reading\n", input_file);
                        return 1;
                    }

                    if (!(f_output = fopen(output_file, "wb"))) {
                        fprintf(stderr, "Could not open %s for writing\n", output_file);
                        return 1;
                    }

                    // Determine buffer size for output
                    if (EVP_PKEY_encrypt(ctx, NULL, &ciphertext_len, buffer, sizeof(buffer)) <= 0)
                        handleErrors();
                    ciphertext = malloc(ciphertext_len);
                    if (!ciphertext) {
                        fprintf(stderr, "Memory allocation failed\n");
                        return 1;
                    }

                    // Encrypt the data
                    while ((bytes_read = fread(buffer, 1, sizeof(buffer), f_input)) > 0) {
                        if (EVP_PKEY_encrypt(ctx, ciphertext, &ciphertext_len, buffer, bytes_read) <= 0)
                            handleErrors();
                        fwrite(ciphertext, 1, ciphertext_len, f_output);
                    }

                    // Clean up
                    EVP_PKEY_free(pubkey);
                    EVP_PKEY_CTX_free(ctx);
                    fclose(f_input);
                    fclose(f_output);
                    free(ciphertext);

                    printf("Encryption complete.\n");

                    return 0;
                }
                ```
            - 解密代码
                ```
                #include <openssl/ec.h>
                #include <openssl/objects.h>
                #include <openssl/evp.h>
                #include <openssl/err.h>
                #include <openssl/pem.h>
                #include <stdio.h>
                #include <stdlib.h>

                void handle_errors() {
                    ERR_print_errors_fp(stderr);
                    abort();
                }

                int main(int argc, char **argv) {
                    if (argc != 4) {
                        fprintf(stderr, "Usage: %s <private_key.pem> <encrypted_file> <decrypted_file>\n", argv[0]);
                        return EXIT_FAILURE;
                    }

                    const char *private_key_file = argv[1];
                    const char *encrypted_file = argv[2];
                    const char *decrypted_file = argv[3];

                    // Load private key
                    EVP_PKEY *private_key = NULL;
                    FILE *fp;
                    fp = fopen(private_key_file, "r");
                    if (!fp) {
                        perror("Error opening private key file");
                        return EXIT_FAILURE;
                    }
                    private_key = PEM_read_PrivateKey(fp, NULL, NULL, NULL);
                    fclose(fp);
                    if (!private_key) {
                        handle_errors();
                        return EXIT_FAILURE;
                    }

                    // Setup decryption
                    EVP_PKEY_CTX *ctx = EVP_PKEY_CTX_new(private_key, NULL);
                    if (!ctx) {
                        handle_errors();
                        return EXIT_FAILURE;
                    }
                    if (EVP_PKEY_decrypt_init(ctx) <= 0) {
                        handle_errors();
                        return EXIT_FAILURE;
                    }

                    // Read encrypted data
                    FILE *fin = fopen(encrypted_file, "rb");
                    if (!fin) {
                        perror("Error opening encrypted file");
                        return EXIT_FAILURE;
                    }
                    // Determine the size of the encrypted data
                    fseek(fin, 0, SEEK_END);
                    long encrypted_data_size = ftell(fin);
                    fseek(fin, 0, SEEK_SET);
                    unsigned char *encrypted_data = malloc(encrypted_data_size);
                    fread(encrypted_data, 1, encrypted_data_size, fin);
                    fclose(fin);

                    // Decrypt data
                    unsigned char *decrypted_data = NULL;
                    size_t decrypted_data_size = 0;
                    if (EVP_PKEY_decrypt(ctx, NULL, &decrypted_data_size, encrypted_data, encrypted_data_size) <= 0) {
                        handle_errors();
                        return EXIT_FAILURE;
                    }
                    decrypted_data = malloc(decrypted_data_size);
                    if (EVP_PKEY_decrypt(ctx, decrypted_data, &decrypted_data_size, encrypted_data, encrypted_data_size) <= 0) {
                        handle_errors();
                        return EXIT_FAILURE;
                    }

                    // Write decrypted data to file
                    FILE *fout = fopen(decrypted_file, "wb");
                    if (!fout) {
                        perror("Error opening decrypted file");
                        return EXIT_FAILURE;
                    }
                    fwrite(decrypted_data, 1, decrypted_data_size, fout);
                    fclose(fout);

                    // Clean up
                    EVP_PKEY_CTX_free(ctx);
                    EVP_PKEY_free(private_key);
                    free(encrypted_data);
                    free(decrypted_data);

                    printf("Decryption successful.\n");
                    return EXIT_SUCCESS;
                }
                ```
    - SM2签名和验证
        - 过程和验证
            ```
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# nano sm2_sign.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# gcc -o sm2_sign sm2_sign.c -lcrypto -lssl
            sm2_sign.c: In function ‘main’:
            sm2_sign.c:29:22: warning: implicit declaration of function ‘PEM_read_PrivateKey’; did you mean ‘i2d_PrivateKey’? [-Wimplicit-function-declaration]
            29 |     EVP_PKEY *pkey = PEM_read_PrivateKey(fp, NULL, NULL, NULL);
                |                      ^~~~~~~~~~~~~~~~~~~
                |                      i2d_PrivateKey
            sm2_sign.c:29:22: warning: initialization of ‘EVP_PKEY *’ {aka ‘struct evp_pkey_st *’} from ‘int’ makes pointer from integer without a cast [-Wint-conversion]
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# rm sm2_sign.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# nano sm2_sign.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# gcc -o sm2_sign sm2_sign.c -lcrypto -lssl
            sm2_sign.c: In function ‘main’:
            sm2_sign.c:30:22: warning: implicit declaration of function ‘PEM_read_Private_key’; did you mean ‘PEM_read_PrivateKey’? [-Wimplicit-function-declaration]
            30 |     EVP_PKEY *pkey = PEM_read_Private_key(fp, NULL, NULL, NULL);
                |                      ^~~~~~~~~~~~~~~~~~~~
                |                      PEM_read_PrivateKey
            sm2_sign.c:30:22: warning: initialization of ‘EVP_PKEY *’ {aka ‘struct evp_pkey_st *’} from ‘int’ makes pointer from integer without a cast [-Wint-conversion]
            /usr/bin/ld: /tmp/ccIzsK7G.o: in function `main':
            sm2_sign.c:(.text+0xed): undefined reference to `PEM_read_Private_key'
            collect2: error: ld returned 1 exit status
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# rm sm2_sign.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# nano sm2_sign.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# gcc -o sm2_sign sm2_sign.c -lcrypto -lssl
            sm2_sign.c:5:10: fatal error: openssl/sm2.h: No such file or directory
                5 | #include <openssl/sm2.h>
                |          ^~~~~~~~~~~~~~~
            compilation terminated.
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# nano sm2_sign.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# gcc -o sm2_sign sm2_sign.c -lcrypto -lssl
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# ./sm2_sign sm2_private.pem plain.txt signature.bin
            Usage: ./sm2_sign <private_key.pem> <input_file>
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# ./sm2_sign sm2_private.pem plain.txt
            Signature: 3046022100cbfb7639a9f9135a99b1993eabbd19fe2cfe573f89177053e6bb374407272cb5022100aa171c3d7a88e775bed2ad536bbc6fb6b36898e00e12000743358dbeca03af08
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# rm sm2_sign.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# nano sm2_sign.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# gcc -o sm2_sign sm2_sign.c -lcrypto -lssl
            sm2_sign.c:5:10: fatal error: openssl/sm2.h: No such file or directory
                5 | #include <openssl/sm2.h>
                |          ^~~~~~~~~~~~~~~
            compilation terminated.
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# nano sm2_sign.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# gcc -o sm2_sign sm2_sign.c -lcrypto -lssl
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# ./sm2_sign sm2_private.pem plain.txt signature.bin
            Signature successfully written to signature.bin
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# nano sm2_verify.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# gcc sm2_verify.c -o sm2_verify -lssl -lcrypto
            sm2_verify.c:5:10: fatal error: openssl/sm2.h: No such file or directory
                5 | #include <openssl/sm2.h>
                |          ^~~~~~~~~~~~~~~
            compilation terminated.
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# nano sm2_verify.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# gcc sm2_verify.c -o sm2_verify -lssl -lcrypto
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# ./sm2_verify sm2_public.pem plain.txt signature.bin
            Signature verification successful!
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# git add .
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# git commit -m "finish sm2 sign & verify"
            [master 8575bbf] finish sm2 sign & verify
            5 files changed, 228 insertions(+)
            create mode 100644 shiyan1-2/task01/test_sm2/signature.bin
            create mode 100755 shiyan1-2/task01/test_sm2/sm2_sign
            create mode 100644 shiyan1-2/task01/test_sm2/sm2_sign.c
            create mode 100755 shiyan1-2/task01/test_sm2/sm2_verify
            create mode 100644 shiyan1-2/task01/test_sm2/sm2_verify.c
            ```
        - 代码（使用evp接口）
            - 签名代码
                ```
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include <openssl/evp.h>
                #include <openssl/pem.h>
                #include <openssl/err.h>

                void handle_errors() {
                    ERR_print_errors_fp(stderr);
                    abort();
                }

                void sign_file(const char *private_key_file, const char *input_file, const char *output_file) {
                    FILE *fp = fopen(input_file, "rb");
                    if (!fp) {
                        perror("Unable to open input file");
                        exit(EXIT_FAILURE);
                    }

                    // 读取文件内容
                    fseek(fp, 0, SEEK_END);
                    long file_size = ftell(fp);
                    fseek(fp, 0, SEEK_SET);
                    unsigned char *data = malloc(file_size);
                    if (!data) {
                        perror("Unable to allocate memory");
                        fclose(fp);
                        exit(EXIT_FAILURE);
                    }
                    fread(data, 1, file_size, fp);
                    fclose(fp);

                    // 读取私钥
                    FILE *key_fp = fopen(private_key_file, "r");
                    if (!key_fp) {
                        perror("Unable to open private key file");
                        free(data);
                        exit(EXIT_FAILURE);
                    }

                    // 从 PEM 文件读取 SM2 私钥
                    EVP_PKEY *pkey = PEM_read_PrivateKey(key_fp, NULL, NULL, NULL);
                    fclose(key_fp);
                    if (!pkey) {
                        handle_errors();
                    }

                    // 创建签名上下文
                    EVP_MD_CTX *ctx = EVP_MD_CTX_new();
                    if (!ctx) {
                        handle_errors();
                    }

                    // 初始化签名操作
                    if (EVP_DigestSignInit(ctx, NULL, EVP_sm3(), NULL, pkey) != 1) {
                        handle_errors();
                    }

                    // 提供要签名的数据
                    if (EVP_DigestSignUpdate(ctx, data, file_size) != 1) {
                        handle_errors();
                    }

                    // 获取签名所需的缓冲区大小
                    size_t sig_len;
                    if (EVP_DigestSignFinal(ctx, NULL, &sig_len) != 1) {
                        handle_errors();
                    }

                    // 分配内存用于签名
                    unsigned char *sig = malloc(sig_len);
                    if (!sig) {
                        perror("Unable to allocate memory for signature");
                        EVP_MD_CTX_free(ctx);
                        EVP_PKEY_free(pkey);
                        free(data);
                        exit(EXIT_FAILURE);
                    }

                    // 获取签名
                    if (EVP_DigestSignFinal(ctx, sig, &sig_len) != 1) {
                        handle_errors();
                    }

                    // 将签名写入输出文件
                    FILE *out_fp = fopen(output_file, "wb");
                    if (!out_fp) {
                        perror("Unable to open output file");
                        free(sig);
                        EVP_MD_CTX_free(ctx);
                        EVP_PKEY_free(pkey);
                        free(data);
                        exit(EXIT_FAILURE);
                    }

                    fwrite(sig, 1, sig_len, out_fp);
                    fclose(out_fp);

                    printf("Signature successfully written to %s\n", output_file);

                    // 清理资源
                    free(sig);
                    EVP_MD_CTX_free(ctx);
                    EVP_PKEY_free(pkey);
                    free(data);
                }

                int main(int argc, char **argv) {
                    if (argc != 4) {
                        fprintf(stderr, "Usage: %s <private_key.pem> <input_file> <output_file>\n", argv[0]);
                        return EXIT_FAILURE;
                    }

                    sign_file(argv[1], argv[2], argv[3]);
                    return EXIT_SUCCESS;
                }
                ```
            - 验证代码
                ```
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include <openssl/evp.h>
                #include <openssl/pem.h>
                #include <openssl/err.h>

                void handle_errors() {
                    ERR_print_errors_fp(stderr);
                    abort();
                }

                int verify_signature(const char *public_key_file, const char *input_file, const char *signature_file) {
                    // 打开输入文件
                    FILE *fp = fopen(input_file, "rb");
                    if (!fp) {
                        perror("Unable to open input file");
                        return EXIT_FAILURE;
                    }

                    // 读取文件内容
                    fseek(fp, 0, SEEK_END);
                    long file_size = ftell(fp);
                    fseek(fp, 0, SEEK_SET);
                    unsigned char *data = malloc(file_size);
                    if (!data) {
                        perror("Unable to allocate memory");
                        fclose(fp);
                        return EXIT_FAILURE;
                    }
                    fread(data, 1, file_size, fp);
                    fclose(fp);

                    // 打开签名文件
                    FILE *sig_fp = fopen(signature_file, "rb");
                    if (!sig_fp) {
                        perror("Unable to open signature file");
                        free(data);
                        return EXIT_FAILURE;
                    }

                    // 读取签名
                    fseek(sig_fp, 0, SEEK_END);
                    long sig_size = ftell(sig_fp);
                    fseek(sig_fp, 0, SEEK_SET);
                    unsigned char *signature = malloc(sig_size);
                    if (!signature) {
                        perror("Unable to allocate memory for signature");
                        fclose(sig_fp);
                        free(data);
                        return EXIT_FAILURE;
                    }
                    fread(signature, 1, sig_size, sig_fp);
                    fclose(sig_fp);

                    // 读取公钥
                    FILE *key_fp = fopen(public_key_file, "r");
                    if (!key_fp) {
                        perror("Unable to open public key file");
                        free(signature);
                        free(data);
                        return EXIT_FAILURE;
                    }

                    // 从 PEM 文件读取 SM2 公钥
                    EVP_PKEY *pkey = PEM_read_PUBKEY(key_fp, NULL, NULL, NULL);
                    fclose(key_fp);
                    if (!pkey) {
                        handle_errors();
                    }

                    // 创建验证上下文
                    EVP_MD_CTX *ctx = EVP_MD_CTX_new();
                    if (!ctx) {
                        handle_errors();
                    }

                    // 初始化验证操作
                    if (EVP_DigestVerifyInit(ctx, NULL, EVP_sm3(), NULL, pkey) != 1) {
                        handle_errors();
                    }

                    // 提供要验证的数据
                    if (EVP_DigestVerifyUpdate(ctx, data, file_size) != 1) {
                        handle_errors();
                    }

                    // 验证签名
                    int ret = EVP_DigestVerifyFinal(ctx, signature, sig_size);
                    if (ret == 1) {
                        printf("Signature verification successful!\n");
                    } else {
                        printf("Signature verification failed!\n");
                    }

                    // 清理资源
                    EVP_MD_CTX_free(ctx);
                    EVP_PKEY_free(pkey);
                    free(signature);
                    free(data);

                    return ret == 1 ? EXIT_SUCCESS : EXIT_FAILURE;
                }

                int main(int argc, char **argv) {
                    if (argc != 4) {
                        fprintf(stderr, "Usage: %s <public_key.pem> <input_file> <signature_file>\n", argv[0]);
                        return EXIT_FAILURE;
                    }

                    return verify_signature(argv[1], argv[2], argv[3]);
                }
                ```

2. 参考相关内容，在 Ubuntu或openEuler中（推荐 openEuler）中使用GmSSL库编程实现调用SM2（加密解密，签名验签），SM3（摘要计算，HMAC 计算），SM4（加密解密）算法，使用Markdown记录详细记录实践过程，每完成一项git commit 一次。（5'）
- sm2加解密、签名与验证
    - sm2密钥对生成（密钥格式：PEM）
        - 过程
            ```
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01# ls
            test_sm2  test_sm3  test_sm4
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task01# cd ..
            root@Youer:~/shiyan/shiyan01/shiyan1-2# mkdir task02
            root@Youer:~/shiyan/shiyan01/shiyan1-2# cd task02
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02# mkdir test_sm2
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02# cd test_sm2
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# mkdir src
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# cd src
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# nano sm2_keygen.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# cd .
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# cd ..
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# mkdir bin
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# gcc -o bin/sm2_keygen src/sm2_keygen.c -lcrypto -lssl
            src/sm2_keygen.c: In function ‘generate_sm2_keypair’:
            src/sm2_keygen.c:22:5: warning: ‘EC_KEY_new’ is deprecated: Since OpenSSL 3.0 [-Wdeprecated-declarations]
            22 |     key = EC_KEY_new();
                |     ^~~
            In file included from src/sm2_keygen.c:1:
            /usr/include/openssl/ec.h:968:31: note: declared here
            968 | OSSL_DEPRECATEDIN_3_0 EC_KEY *EC_KEY_new(void);
                |                               ^~~~~~~~~~
            src/sm2_keygen.c:30:5: warning: ‘EC_KEY_set_group’ is deprecated: Since OpenSSL 3.0 [-Wdeprecated-declarations]
            30 |     if (!EC_KEY_set_group(key, group)) {
                |     ^~
            In file included from src/sm2_keygen.c:1:
            /usr/include/openssl/ec.h:1042:27: note: declared here
            1042 | OSSL_DEPRECATEDIN_3_0 int EC_KEY_set_group(EC_KEY *key, const EC_GROUP *group);
                |                           ^~~~~~~~~~~~~~~~
            src/sm2_keygen.c:37:5: warning: ‘EC_KEY_generate_key’ is deprecated: Since OpenSSL 3.0 [-Wdeprecated-declarations]
            37 |     if (!EC_KEY_generate_key(key)) {
                |     ^~
            In file included from src/sm2_keygen.c:1:
            /usr/include/openssl/ec.h:1101:27: note: declared here
            1101 | OSSL_DEPRECATEDIN_3_0 int EC_KEY_generate_key(EC_KEY *key);
                |                           ^~~~~~~~~~~~~~~~~~~
            src/sm2_keygen.c:59:10: warning: implicit declaration of function ‘PEM_write_ECPrivateKey’; did you mean ‘i2d_ECPrivateKey’? [-Wimplicit-function-declaration]
            59 |     if (!PEM_write_ECPrivateKey(priv_file, key, NULL, NULL, 0, NULL, NULL)) {
                |          ^~~~~~~~~~~~~~~~~~~~~~
                |          i2d_ECPrivateKey
            src/sm2_keygen.c:67:10: warning: implicit declaration of function ‘PEM_write_ECPublicKey’ [-Wimplicit-function-declaration]
            67 |     if (!PEM_write_ECPublicKey(pub_file, key)) {
                |          ^~~~~~~~~~~~~~~~~~~~~
            src/sm2_keygen.c:82:5: warning: ‘EC_KEY_free’ is deprecated: Since OpenSSL 3.0 [-Wdeprecated-declarations]
            82 |     if (key) EC_KEY_free(key);
                |     ^~
            In file included from src/sm2_keygen.c:1:
            /usr/include/openssl/ec.h:1003:28: note: declared here
            1003 | OSSL_DEPRECATEDIN_3_0 void EC_KEY_free(EC_KEY *key);
                |                            ^~~~~~~~~~~
            /usr/bin/ld: /tmp/ccfzDR1u.o: in function `generate_sm2_keypair':
            sm2_keygen.c:(.text+0x28b): undefined reference to `PEM_write_ECPublicKey'
            collect2: error: ld returned 1 exit status
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# rm src/sm2_keygen.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# cd src
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# nano sm2_keygen.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# gcc -o ../bin/sm2_keygen sm2_keygen.c -lcrypto -lssl
            sm2_keygen.c: In function ‘generate_sm2_keypair’:
            sm2_keygen.c:23:5: warning: ‘EC_KEY_new_method’ is deprecated: Since OpenSSL 3.0 [-Wdeprecated-declarations]
            23 |     key = EC_KEY_new_method(NULL); // 使用新的API
                |     ^~~
            In file included from sm2_keygen.c:1:
            /usr/include/openssl/ec.h:1284:31: note: declared here
            1284 | OSSL_DEPRECATEDIN_3_0 EC_KEY *EC_KEY_new_method(ENGINE *engine);
                |                               ^~~~~~~~~~~~~~~~~
            sm2_keygen.c:31:5: warning: ‘EC_KEY_set_group’ is deprecated: Since OpenSSL 3.0 [-Wdeprecated-declarations]
            31 |     if (!EC_KEY_set_group(key, group)) {
                |     ^~
            In file included from sm2_keygen.c:1:
            /usr/include/openssl/ec.h:1042:27: note: declared here
            1042 | OSSL_DEPRECATEDIN_3_0 int EC_KEY_set_group(EC_KEY *key, const EC_GROUP *group);
                |                           ^~~~~~~~~~~~~~~~
            sm2_keygen.c:38:5: warning: ‘EC_KEY_generate_key’ is deprecated: Since OpenSSL 3.0 [-Wdeprecated-declarations]
            38 |     if (!EC_KEY_generate_key(key)) {
                |     ^~
            In file included from sm2_keygen.c:1:
            /usr/include/openssl/ec.h:1101:27: note: declared here
            1101 | OSSL_DEPRECATEDIN_3_0 int EC_KEY_generate_key(EC_KEY *key);
                |                           ^~~~~~~~~~~~~~~~~~~
            sm2_keygen.c:60:5: warning: ‘PEM_write_ECPrivateKey’ is deprecated: Since OpenSSL 3.0 [-Wdeprecated-declarations]
            60 |     if (!PEM_write_ECPrivateKey(priv_file, key, NULL, NULL, 0, NULL, NULL)) {
                |     ^~
            In file included from sm2_keygen.c:4:
            /usr/include/openssl/pem.h:462:1: note: declared here
            462 | DECLARE_PEM_rw_cb_attr(OSSL_DEPRECATEDIN_3_0, ECPrivateKey, EC_KEY)
                | ^~~~~~~~~~~~~~~~~~~~~~
            sm2_keygen.c:63:7: error: ‘el’ undeclared (first use in this function)
            63 |     } el
                |       ^~
            sm2_keygen.c:63:7: note: each undeclared identifier is reported only once for each function it appears in
            sm2_keygen.c:63:9: error: expected ‘;’ at end of input
            63 |     } el
                |         ^
                |         ;
            sm2_keygen.c:63:5: error: expected declaration or statement at end of input
            63 |     } el
                |     ^
            sm2_keygen.c:56:9: error: label ‘cleanup’ used but not defined
            56 |         goto cleanup;
                |         ^~~~
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# rm sm2_keygen.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# nano sm2_keygen.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# gcc -o ../bin/sm2_keygen sm2_keygen.c -lcrypto -lssl
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# cd ..
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# ./bin/sm2_keygen private_key.pem public_key.pem
            Private key written to private_key.pem
            Public key written to public_key.pem
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# ls
            bin  private_key.pem  public_key.pem  src
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# git add .
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# git commit -m "gmssl:create keys by code"
            [master 0ae010f] gmssl:create keys by code
            4 files changed, 98 insertions(+)
            create mode 100755 shiyan1-2/task02/test_sm2/bin/sm2_keygen
            create mode 100644 shiyan1-2/task02/test_sm2/private_key.pem
            create mode 100644 shiyan1-2/task02/test_sm2/public_key.pem
            create mode 100644 shiyan1-2/task02/test_sm2/src/sm2_keygen.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# nano src/sm2_keygen.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# gcc -o ../bin/sm2_keygen src/sm2_keygen.c -lcrypto -lssl
            src/sm2_keygen.c: In function ‘main’:
            src/sm2_keygen.c:15:24: warning: implicit declaration of function ‘sm2_key_new’; did you mean ‘sm2_key_print’? [-Wimplicit-function-declaration]
            15 |     SM2_KEY *sm2_key = sm2_key_new();
                |                        ^~~~~~~~~~~
                |                        sm2_key_print
            src/sm2_keygen.c:15:24: warning: initialization of ‘SM2_KEY *’ from ‘int’ makes pointer from integer without a cast [-Wint-conversion]
            src/sm2_keygen.c:21:9: error: too many arguments to function ‘sm2_key_generate’
            21 |     if (sm2_key_generate(sm2_key, 256) != 1) {
                |         ^~~~~~~~~~~~~~~~
            In file included from src/sm2_keygen.c:3:
            /usr/local/include/gmssl/sm2.h:31:5: note: declared here
            31 | int sm2_key_generate(SM2_KEY *key);
                |     ^~~~~~~~~~~~~~~~
            src/sm2_keygen.c:23:9: warning: implicit declaration of function ‘sm2_key_free’; did you mean ‘sm2_key_print’? [-Wimplicit-function-declaration]
            23 |         sm2_key_free(sm2_key);
                |         ^~~~~~~~~~~~
                |         sm2_key_print
            src/sm2_keygen.c:34:9: warning: implicit declaration of function ‘sm2_key_write_private_key’; did you mean ‘sm2_key_set_private_key’? [-Wimplicit-function-declaration]
            34 |     if (sm2_key_write_private_key(sm2_key, fp_private) != 1) {
                |         ^~~~~~~~~~~~~~~~~~~~~~~~~
                |         sm2_key_set_private_key
            src/sm2_keygen.c:49:9: warning: implicit declaration of function ‘sm2_key_write_public_key’; did you mean ‘sm2_key_set_public_key’? [-Wimplicit-function-declaration]
            49 |     if (sm2_key_write_public_key(sm2_key, fp_public) != 1) {
                |         ^~~~~~~~~~~~~~~~~~~~~~~~
                |         sm2_key_set_public_key
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# rm src/sm2_keygen.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# nano src/sm2_keygen.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# ls
            bin  private_key.pem  public_key.pem  sm2_keygen.c  src
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# cp ./sm2_keygen.c ./src/
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# ls
            bin  private_key.pem  public_key.pem  sm2_keygen.c  src
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# rm sm2_keygen.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# gcc -o ../bin/sm2_keygen src/sm2_keygen.c -lcrypto -lssl
            /usr/bin/ld: cannot open output file ../bin/sm2_keygen: No such file or directory
            collect2: error: ld returned 1 exit status
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# tree
            .
            ├── bin
            │   └── sm2_keygen
            ├── private_key.pem
            ├── public_key.pem
            └── src
                └── sm2_keygen.c

            2 directories, 4 files
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# gcc -o ../bin/sm2_keygen src/sm2_keygen.c -lcrypto -lssl
            /usr/bin/ld: cannot open output file ../bin/sm2_keygen: No such file or directory
            collect2: error: ld returned 1 exit status
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# gcc -o ./bin/sm2_keygen src/sm2_keygen.c -lcrypto -lssl
            /usr/bin/ld: /tmp/ccq6xvrX.o: in function `main':
            sm2_keygen.c:(.text+0x95): undefined reference to `sm2_key_generate'
            /usr/bin/ld: sm2_keygen.c:(.text+0x123): undefined reference to `sm2_private_key_info_to_pem'
            /usr/bin/ld: sm2_keygen.c:(.text+0x1cc): undefined reference to `sm2_public_key_info_to_pem'
            collect2: error: ld returned 1 exit status
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# gcc -o bin/sm2_keygen src/sm2_keygen.c -lcrypto -lssl
            /usr/bin/ld: /tmp/ccR5ZVHB.o: in function `main':
            sm2_keygen.c:(.text+0x95): undefined reference to `sm2_key_generate'
            /usr/bin/ld: sm2_keygen.c:(.text+0x123): undefined reference to `sm2_private_key_info_to_pem'
            /usr/bin/ld: sm2_keygen.c:(.text+0x1cc): undefined reference to `sm2_public_key_info_to_pem'
            collect2: error: ld returned 1 exit status
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# gcc -o bin/sm2_keygen src/sm2_keygen.c -lcrypto -lssl -L/usr/local/lib -lgmssl
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# tree
            .
            ├── bin
            │   └── sm2_keygen
            ├── private_key.pem
            ├── public_key.pem
            └── src
                └── sm2_keygen.c

            2 directories, 4 files
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# ./bin/sm2_keygen private_key.pem public_key.pem
            SM2 key pair generated successfully.
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# ls
            bin  private_key.pem  public_key.pem  src
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# rm *.pem
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# ./bin/sm2_keygen private_key.pem public_key.pem
            SM2 key pair generated successfully.
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# ls
            bin  private_key.pem  public_key.pem  src
            ```
        - 代码
            ```
            #include <stdio.h>
            #include <stdlib.h>
            #include <gmssl/sm2.h>
            #include <gmssl/error.h>
            #include <gmssl/pem.h>

            int main(int argc, char **argv) {
                if (argc != 3) {
                    fprintf(stderr, "Usage: %s <private_key_file> <public_key_file>\n", argv[0]);
                    return 1;
                }

                const char *private_key_file = argv[1];
                const char *public_key_file = argv[2];

                SM2_KEY sm2_key;
                FILE *fp;

                // 生成SM2密钥对
                if (sm2_key_generate(&sm2_key) != 1) {
                    fprintf(stderr, "Failed to generate SM2 key pair.\n");
                    return 1;
                }

                // 保存私钥
                if (!(fp = fopen(private_key_file, "wb"))) {
                    perror("Failed to open private key file");
                    return 1;
                }
                if (sm2_private_key_info_to_pem(&sm2_key, fp) != 1) {
                    fprintf(stderr, "Failed to write private key to file.\n");
                    fclose(fp);
                    return 1;
                }
                fclose(fp);

                // 保存公钥
                if (!(fp = fopen(public_key_file, "wb"))) {
                    perror("Failed to open public key file");
                    return 1;
                }
                if (sm2_public_key_info_to_pem(&sm2_key, fp) != 1) {
                    fprintf(stderr, "Failed to write public key to file.\n");
                    fclose(fp);
                    return 1;
                }
                fclose(fp);

                printf("SM2 key pair generated successfully.\n");
                return 0;
            }
            ```
    - sm2加解密
        - 过程与验证
            ```
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# rm sm2_encrypt.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# nano sm2_encrypt.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# gcc -o ../bin/sm2_encrypt sm2_encrypt.c -lgmssl -lssl -lcrypto
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# cd ..
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# tree
            .
            ├── bin
            │   ├── sm2_decrypt
            │   ├── sm2_encrypt
            │   └── sm2_keygen
            ├── private_key.pem
            ├── public_key.pem
            ├── src
            │   ├── sm2_decrypt.c
            │   ├── sm2_encrypt.c
            │   └── sm2_keygen.c
            └── test
                ├── decrypt.bin
                ├── encrypt.bin
                └── plain.txt

            3 directories, 11 files
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# ./bin/sm2_encrypt public_key.pem ./test/plain.txt ./test/encrypt.bin
            Encryption successful, output written to ./test/encrypt.bin
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# cd src
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# nano sm2_decrypt.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# cd ..
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# ./bin/sm2_decrypt private_key.pem ./test/encrypt.bin ./test/decrypt.bin
            Invalid SM2 key length: must be 64 hex characters.
            Invalid SM2 key.
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# cd src
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# ls
            sm2_decrypt.c  sm2_encrypt.c  sm2_keygen.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# rm sm2_decrypt.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# nano sm2_decrypt.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# gcc -o ../bin/sm2_decrypt sm2_decrypt.c -lgmssl -lssl -lcryp
            to
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# cd ..
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2#  ./bin/sm2_decrypt private_key.pem ./test/encrypt.bin ./test/decrypt.bin
            Decryption successful, output written to ./test/decrypt.bin
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# cat ./test/decrypt.bin
            20221414xlm
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# git add .
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# git commit -m "finish gmssl sm2 encrypt & decrypt"
            [master 8ccde69] finish gmssl sm2 encrypt & decrypt
            11 files changed, 231 insertions(+), 94 deletions(-)
            create mode 100755 shiyan1-2/task02/test_sm2/bin/sm2_decrypt
            create mode 100755 shiyan1-2/task02/test_sm2/bin/sm2_encrypt
            rewrite shiyan1-2/task02/test_sm2/bin/sm2_keygen (60%)
            create mode 100644 shiyan1-2/task02/test_sm2/src/sm2_decrypt.c
            create mode 100644 shiyan1-2/task02/test_sm2/src/sm2_encrypt.c
            rewrite shiyan1-2/task02/test_sm2/src/sm2_keygen.c (90%)
            create mode 100644 shiyan1-2/task02/test_sm2/test/decrypt.bin
            create mode 100644 shiyan1-2/task02/test_sm2/test/encrypt.bin
            create mode 100644 shiyan1-2/task02/test_sm2/test/plain.txt
            ```
        - 代码
            - 加密
                ```
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include <gmssl/sm2.h>
                #include <gmssl/pem.h>

                #define SM2_CIPHERTEXT_SIZE 1024  // 根据需要调整大小

                void print_usage() {
                    printf("Usage: sm2_encrypt <public_key.pem> <input_file> <output_file>\n");
                }

                int main(int argc, char *argv[]) {
                    if (argc != 4) {
                        print_usage();
                        return 1;
                    }

                    const char *public_key_file = argv[1];
                    const char *input_file = argv[2];
                    const char *output_file = argv[3];

                    // Load public key
                    SM2_KEY sm2_key;
                    FILE *fp = fopen(public_key_file, "r");
                    if (!fp) {
                        perror("Failed to open public key file");
                        return 1;
                    }

                    // Use the correct function to read the public key
                    if (sm2_public_key_info_from_pem(&sm2_key, fp) != 1) {
                        fprintf(stderr, "Failed to read public key from PEM\n");
                        fclose(fp);
                        return 1;
                    }
                    fclose(fp);

                    // Read input file
                    FILE *in_fp = fopen(input_file, "rb");
                    if (!in_fp) {
                        perror("Failed to open input file");
                        return 1;
                    }

                    fseek(in_fp, 0, SEEK_END);
                    long input_len = ftell(in_fp);
                    fseek(in_fp, 0, SEEK_SET);
                    unsigned char *input_data = malloc(input_len);
                    if (fread(input_data, 1, input_len, in_fp) != input_len) {
                        perror("Failed to read input file");
                        free(input_data);
                        fclose(in_fp);
                        return 1;
                    }
                    fclose(in_fp);

                    // Encrypt data
                    unsigned char ciphertext[SM2_CIPHERTEXT_SIZE];
                    size_t ciphertext_len = sizeof(ciphertext);

                    if (sm2_encrypt(&sm2_key, input_data, input_len, ciphertext, &ciphertext_len) != 1) {
                        fprintf(stderr, "SM2 encryption failed\n");
                        free(input_data);
                        return 1;
                    }

                    free(input_data);

                    // Write output file
                    FILE *out_fp = fopen(output_file, "wb");
                    if (!out_fp) {
                        perror("Failed to open output file");
                        return 1;
                    }

                    if (fwrite(ciphertext, 1, ciphertext_len, out_fp) != ciphertext_len) {
                        perror("Failed to write output file");
                        fclose(out_fp);
                        return 1;
                    }
                    fclose(out_fp);

                    printf("Encryption successful, output written to %s\n", output_file);
                    return 0;
                }
                ```
            - 解密
                ```
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include <gmssl/sm2.h>
                #include <gmssl/pem.h>

                #define SM2_CIPHERTEXT_SIZE 1024  // 根据需要调整大小

                void print_usage() {
                    printf("Usage: sm2_decrypt <private_key.pem> <input_file> <output_file>\n");
                }

                int main(int argc, char *argv[]) {
                    if (argc != 4) {
                        print_usage();
                        return 1;
                    }

                    const char *private_key_file = argv[1];
                    const char *input_file = argv[2];
                    const char *output_file = argv[3];

                    // Load private key
                    SM2_KEY sm2_key;
                    FILE *fp = fopen(private_key_file, "r");
                    if (!fp) {
                        perror("Failed to open private key file");
                        return 1;
                    }

                    // 使用 PEM 格式加载私钥
                    if (sm2_private_key_info_from_pem(&sm2_key, fp) != 1) {
                        fprintf(stderr, "Failed to read private key from PEM\n");
                        fclose(fp);
                        return 1;
                    }
                    fclose(fp);

                    // Read input file (ciphertext)
                    FILE *in_fp = fopen(input_file, "rb");
                    if (!in_fp) {
                        perror("Failed to open input file");
                        return 1;
                    }

                    fseek(in_fp, 0, SEEK_END);
                    long input_len = ftell(in_fp);
                    fseek(in_fp, 0, SEEK_SET);
                    unsigned char *ciphertext = malloc(input_len);
                    if (fread(ciphertext, 1, input_len, in_fp) != input_len) {
                        perror("Failed to read input file");
                        free(ciphertext);
                        fclose(in_fp);
                        return 1;
                    }
                    fclose(in_fp);

                    // 解密数据
                    unsigned char decrypted[SM2_CIPHERTEXT_SIZE];  // 根据需要调整大小
                    size_t decrypted_len = sizeof(decrypted);

                    if (sm2_decrypt(&sm2_key, ciphertext, input_len, decrypted, &decrypted_len) != 1) {
                        fprintf(stderr, "SM2 decryption failed\n");
                        free(ciphertext);
                        return 1;
                    }

                    free(ciphertext);

                    // Write output file
                    FILE *out_fp = fopen(output_file, "wb");
                    if (!out_fp) {
                        perror("Failed to open output file");
                        return 1;
                    }

                    if (fwrite(decrypted, 1, decrypted_len, out_fp) != decrypted_len) {
                        perror("Failed to write output file");
                        fclose(out_fp);
                        return 1;
                    }
                    fclose(out_fp);

                    printf("Decryption successful, output written to %s\n", output_file);
                    return 0;
                }
                ```
    - sm2签名和验证
        - 过程与验证
            ```
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# rm sm2_sign.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# nano sm2_sign.c
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# gcc -o ../bin/sm2_sign sm2_sign.c -lgmssl -lssl -lcrypt
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# ../bin/sm2_sign ../private_key.pem ../test/plain.txt ../test/signature.sig
            /root/GmSSL/src/pem.c:100:pem_read():
            /root/GmSSL/src/sm2_key.c:466:sm2_private_key_from_pem():
            Error loading private key from PEM file: ../private_key.pem
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# openssl pkey -in ../private_key.pem -out ../private_key_ec.pem -outform PEM -traditional
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# ../bin/sm2_sign ../private_key_ec.pem ../test/plain.txt ../t
            est/signature.sig
            Signature generated and saved to ../test/signature.sig
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# gmssl sm2verify -pubkey ../public_key.pem -in ../test/plain.
            txt -sig ../test/signature.sig
            /root/GmSSL/src/sm2_sign.c:265:sm2_fast_verify():
            /root/GmSSL/src/sm2_sign.c:671:sm2_verify_finish():
            gmssl sm2verify: inner error
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# cd ..
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# ls
            bin  private_key.pem  private_key_ec.pem  public_key.pem  src  test
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# rm private_key.pem
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# mv private_key_ec.pem private_key.pem
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# cd src
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# ../bin/sm2_verify ../public_key.pem ../test/plain.txt ../test/signature.sig
            Signature is valid.
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# cd src
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# ../bin/sm2_sign ../private_key.pem ../test/plain.txt ../test/signature.sig
            Signature generated and saved to ../test/signature.sig
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2/src# ../bin/sm2_verify ../public_key.pem ../test/plain.txt ../test/signature.sig
            Signature is valid.
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# git add .
            root@Youer:~/shiyan/shiyan01/shiyan1-2/task02/test_sm2# git commit -m "finish sm2 sign & verify by PKCS#8 key"
            [master de0b95b] finish sm2 sign & verify by PKCS#8 key
            10 files changed, 249 insertions(+), 205 deletions(-)
            create mode 100755 shiyan1-2/task02/test_sm2/bin/sm2_sign
            create mode 100755 shiyan1-2/task02/test_sm2/bin/sm2_verify
            create mode 100644 shiyan1-2/task02/test_sm2/src/sm2_keygen_pem.c
            rewrite shiyan1-2/task02/test_sm2/src/sm2_sign.c (73%)
            rewrite shiyan1-2/task02/test_sm2/src/sm2_verify.c (85%)
            create mode 100644 shiyan1-2/task02/test_sm2/test/signature.sig
            ```
        - 代码
            - 签名
                ```
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include <gmssl/sm2.h>
                #include <gmssl/pem.h>
                #include <gmssl/error.h>
                #include <gmssl/sm3.h>

                int main(int argc, char **argv)
                {
                    if (argc != 4) {
                        printf("Usage: %s <private_key.pem> <input.txt> <signature.sig>\n", argv[0]);
                        return 1;
                    }

                    const char *private_key_file = argv[1];
                    const char *input_file = argv[2];
                    const char *signature_file = argv[3];

                    SM2_KEY sm2_key;
                    FILE *key_fp = NULL;
                    FILE *input_fp = NULL;
                    FILE *sig_fp = NULL;
                    unsigned char dgst[32];
                    unsigned char sig[SM2_MAX_SIGNATURE_SIZE];
                    size_t siglen;
                    unsigned char buffer[1024];
                    size_t len;

                    // 加载私钥
                    key_fp = fopen(private_key_file, "r");
                    if (!key_fp) {
                        perror("Failed to open private key file");
                        return 1;
                    }

                    // 使用 PEM 格式加载私钥
                    if (sm2_private_key_info_from_pem(&sm2_key, key_fp) != 1) {
                        fprintf(stderr, "Failed to read private key from PEM\n");
                        fclose(key_fp);
                        return 1;
                    }
                    fclose(key_fp);

                    // 读取输入文件并计算SM3哈希
                    input_fp = fopen(input_file, "r");
                    if (!input_fp) {
                        fprintf(stderr, "Error opening input file: %s\n", input_file);
                        return 1;
                    }

                    SM3_CTX sm3_ctx;
                    sm3_init(&sm3_ctx);

                    while ((len = fread(buffer, 1, sizeof(buffer), input_fp)) > 0) {
                        sm3_update(&sm3_ctx, buffer, len);
                    }
                    fclose(input_fp);

                    sm3_finish(&sm3_ctx, dgst);

                    // 生成签名
                    siglen = sizeof(sig);  // 确保我们为签名的大小传递正确的变量
                    if (sm2_sign(&sm2_key, dgst, sig, &siglen) != 1) {
                        fprintf(stderr, "Error generating SM2 signature\n");
                        return 1;
                    }

                    // 写入签名到文件
                    sig_fp = fopen(signature_file, "wb");
                    if (!sig_fp) {
                        fprintf(stderr, "Error opening signature file: %s\n", signature_file);
                        return 1;
                    }

                    if (fwrite(sig, 1, siglen, sig_fp) != siglen) {
                        fprintf(stderr, "Error writing signature to file: %s\n", signature_file);
                        fclose(sig_fp);
                        return 1;
                    }
                    fclose(sig_fp);

                    printf("Signature generated and saved to %s\n", signature_file);
                    return 0;
                }
                ```
            - 验证
                ```
                #include <stdio.h>
                #include <stdlib.h>
                #include <string.h>
                #include <gmssl/sm2.h>
                #include <gmssl/sm3.h>
                #include <gmssl/pem.h>
                #include <gmssl/error.h>

                int main(int argc, char **argv) {
                    if (argc != 4) {
                        fprintf(stderr, "Usage: %s <public key PEM file> <input file> <signature file>\n", argv[0]);
                        return 1;
                    }

                    const char *pubkey_filename = argv[1];
                    const char *input_filename = argv[2];
                    const char *signature_filename = argv[3];

                    SM2_KEY key;
                    FILE *fp;
                    SM3_CTX sm3_ctx;
                    uint8_t dgst[32]; // SM3摘要结果大小

                    // 读取公钥
                    if (!(fp = fopen(pubkey_filename, "r"))) {
                        perror("Error opening public key file"); // 使用 perror 打印系统错误信息
                        return 1;
                    }
                    if (!sm2_public_key_info_from_pem(&key, fp)) {
                        fprintf(stderr, "Error reading public key from PEM file %s\n", pubkey_filename);
                        fclose(fp);
                        return 1;
                    }
                    fclose(fp);

                    // 读取输入文件并计算哈希
                    if (!(fp = fopen(input_filename, "rb"))) {
                        perror("Error opening input file"); // 使用 perror 打印系统错误信息
                        return 1;
                    }

                    sm3_init(&sm3_ctx);
                    unsigned char buf[1024];
                    size_t len;
                    while ((len = fread(buf, 1, sizeof(buf), fp)) > 0) {
                        sm3_update(&sm3_ctx, buf, len);
                    }
                    if (ferror(fp)) {
                        fprintf(stderr, "Error reading input file %s\n", input_filename);
                        fclose(fp);
                        return 1;
                    }
                    sm3_finish(&sm3_ctx, dgst);
                    fclose(fp);

                    // 读取签名
                    unsigned char signature[256];
                    size_t siglen;
                    if (!(fp = fopen(signature_filename, "rb"))) {
                        perror("Error opening signature file"); // 使用 perror 打印系统错误信息
                        return 1;
                    }
                    siglen = fread(signature, 1, sizeof(signature), fp);
                    if (ferror(fp)) {
                        fprintf(stderr, "Error reading signature file %s\n", signature_filename);
                        fclose(fp);
                        return 1;
                    }
                    fclose(fp);

                    // 确保读取的签名长度有效
                    if (siglen == 0) {
                        fprintf(stderr, "Signature file %s is empty or could not be read.\n", signature_filename);
                        return 1;
                    }

                    // 验证签名
                    int verify_result = sm2_verify(&key, dgst, signature, siglen);
                    if (verify_result == 1) {
                        printf("Signature is valid.\n");
                    } else {
                        fprintf(stderr, "Signature is invalid. Please check the public key, input file, and signature file.\n");
                        return 1;
                    }

                    return 0;
                }
                ```
- sm3摘要计算和HMAC

- sm4加解密

3. 两人一组，在 Ubuntu或openEuler中（推荐 openEuler）中使用OpenSSL编程实现带签名的数字信封协议。使用OpenSSL库时，Alice发送，Bob接收。Ailice，Bob在实验中要替换为自己的8位学号+姓名。 使用Markdown记录详细记录实践过程，每完成一项git commit 一次。（5分）

- Alice,Bob生成自己的公私钥匙对，记作：（PKa，SKa），（PKb，SKb），Alice,Bob分别拥有：（PKa，SKa，PKb），（PKb，SKb，PKa），实验中把公钥文件拷贝给对方
- Alice发给Bob的明文plain.txt，内容为自己的姓名学号
- Alice：sm4 key使用gmssl rand 产生，16字节，记作k
- Alice：Sm4Enc(k,P) = C
- Alice：Sm2Enc(PKb,k) = KC
- Alice：Sm2Sign（SKa，C）= S1
- Alice： 数字信封 C||KC||S1  发给Bob
- Bob：Sm2Very（PKa，S1）
- Bob：Sm2Dec（SKb，KC）= k
- Bob：Sm4Dec（k，C）= P

4. 两人一组，在 Ubuntu或openEuler中（推荐 openEuler）中使用GmSSL编程实现带签名的数字信封协议。使用GmSSL库时，Bob发送，Alice接收。Ailice，Bob在实验中要替换为自己的8位学号+姓名。 使用Markdown记录详细记录实践过程，每完成一项git commit 一次。（5分）
5. 使用Rust完成带签名的数字信封协议（选做，10分）
6. 实验记录中提交 gitee 课程项目链接，提交本次实验相关 git log运行结果
7. 提交要求：

- 提交实践过程Markdown和转化的PDF文件
- 代码，文档托管到gitee或github等，推荐 gitclone
- 记录实验过程中遇到的问题，解决过程，反思等内容，用于后面实验报告

- 第一步的sm2代码解密失败，提示ASN.1编码出错
    - 原代码
        ```
        #include <openssl/evp.h>
        #include <openssl/pem.h>
        #include <stdio.h>
        #include <stdlib.h>

        void handleErrors(void) {
            fprintf(stderr, "An error occurred.\n");
            exit(1);
        }

        int main(int argc, char *argv[]) {
            if (argc != 4) {
                fprintf(stderr, "Usage: %s <privkey.pem> <input file> <output file>\n", argv[0]);
                return 1;
            }

            char *privkey_filename = argv[1];
            char *input_file = argv[2];
            char *output_file = argv[3];

            FILE *f_input, *f_output, *f_privkey;
            unsigned char buffer[1024];
            unsigned char *plaintext;
            size_t plaintext_len;
            size_t bytes_read;  // 声明 bytes_read 变量

            EVP_PKEY *privkey = NULL;
            EVP_PKEY_CTX *ctx = NULL;

            // Load private key
            if (!(f_privkey = fopen(privkey_filename, "r"))) {
                fprintf(stderr, "Unable to open private key file %s\n", privkey_filename);
                return 1;
            }

            if (!(privkey = PEM_read_PrivateKey(f_privkey, NULL, NULL, NULL))) {
                fprintf(stderr, "Error loading private key\n");
                fclose(f_privkey);
                return 1;
            }
            fclose(f_privkey);

            // Initialise the library
            if (!OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL))
                handleErrors();

            // Create and initialise the context
            if (!(ctx = EVP_PKEY_CTX_new(privkey, NULL)))
                handleErrors();

            if (EVP_PKEY_decrypt_init(ctx) <= 0)
                handleErrors();

            // Open files
            if (!(f_input = fopen(input_file, "rb"))) {
                fprintf(stderr, "Could not open %s for reading\n", input_file);
                return 1;
            }

            if (!(f_output = fopen(output_file, "wb"))) {
                fprintf(stderr, "Could not open %s for writing\n", output_file);
                return 1;
            }

            // Determine buffer size for output
            if (EVP_PKEY_decrypt(ctx, NULL, &plaintext_len, buffer, sizeof(buffer)) <= 0)
                handleErrors();
            plaintext = malloc(plaintext_len);

            // Decrypt the data
            while ((bytes_read = fread(buffer, 1, sizeof(buffer), f_input)) > 0) {
                if (EVP_PKEY_decrypt(ctx, plaintext, &plaintext_len, buffer, bytes_read) <= 0)
                    handleErrors();
                fwrite(plaintext, 1, plaintext_len, f_output);
            }

            // Clean up
            EVP_PKEY_free(privkey);
            EVP_PKEY_CTX_free(ctx);
            fclose(f_input);
            fclose(f_output);
            free(plaintext);

            printf("Decryption complete.\n");

            return 0;
        }

        ```
    - 报错
        ```
        root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# ./sm2_decrypt sm2_private.pem encrypted_file.bin decrypted_file.bin
        OpenSSL error: error:068000A8:asn1 encoding routines::wrong tag
        OpenSSL error: error:0688010A:asn1 encoding routines::nested asn1 error
        OpenSSL error: error:1A800068:SM2 routines::reason(104)
        ```
    - 具体表现：
        - 无法通过代码进行解密，但可以通过openssl命令解密
        - 在询问中，AI的代码无法跳出这一bug，且总是重复一些已经排除的可能
    - 最终解决：
        - 明确根本问题：需要一个调用openssl库且从命令行接受密钥和加解密文件的SM2解密函数
        - 最终舍弃了之前的讨论才得到了正确答案
    - [解决问题的具体对话](https://kimi.moonshot.cn/share/cs747blvbf6t016f5m6g)
            ```
            User: ./sm2_decrypt sm2_private.pem encrypted_file decrypted_file
            An error occurred.
            这该怎么办 

            Kimi: 出现 "An error occurred." 的错误消息通常意味着在程序执行过程中遇到了问题，但并没有提供具体的错误信息。为了进一步诊断问题，我们可以采取以下步骤：

            1. **检查输入文件**：确保 `encrypted_file` 是存在的，并且其内容是使用相应的公钥正确加密的。如果文件为空或损坏，解密操作可能会失败。

            2. **检查私钥**：确保 `sm2_private.pem` 文件包含正确的私钥，并且该私钥与用于加密的公钥是匹配的。如果私钥不正确或格式有误，解密也会失败。

            3. **查看 OpenSSL 错误队列**：OpenSSL 库维护了一个错误队列，当函数调用失败时，可以在程序中检查这些错误。修改 `handleErrors` 函数来打印出错误信息：

            ```c
            void handleErrors(void) {
                unsigned long err;
                while ((err = ERR_get_error()) != 0) {
                    char buf[256];
                    ERR_error_string_n(err, buf, sizeof(buf));
                    fprintf(stderr, "OpenSSL error: %s\n", buf);
                }
                exit(1);
            }
            ```

            4. **确保正确的库和算法**：如果你正在使用 SM2 算法，确保你的 OpenSSL 库支持 SM2，并且你使用的是正确的初始化和加密函数。

            5. **检查内存分配**：确保 `malloc` 为 `plaintext` 分配的内存是足够的。如果 `EVP_PKEY_decrypt` 需要更多的空间来存储解密后的数据，而分配的空间不足，这也可能导致错误。

            6. **检查文件读写权限**：确保程序有权限读取输入文件和写入输出文件。

            7. **调试程序**：如果可能的话，使用调试器来逐步执行程序，观察在哪一步出现了问题。

            8. **查看程序输出**：运行程序时，注意查看是否有其他输出信息，这可能会提供问题的线索。

            9. **检查代码逻辑**：重新检查代码逻辑，确保所有的步骤都是正确的，并且符合 OpenSSL 的使用要求。

            如果在采取了上述步骤后仍然无法解决问题，你可能需要提供更多的上下文信息，例如私钥和加密文件的内容（如果可能的话），以便进一步分析。记住，不要在公共场合或不安全的环境中泄露你的私钥或敏感数据。 

            User: 请给我修改完成的代码 

            Kimi: 当然，以下是修改后的完整代码，包括了从 OpenSSL 错误队列中提取并打印错误信息的功能。这将帮助你诊断在运行程序时遇到的问题。

            ```c
            #include <openssl/evp.h>
            #include <openssl/pem.h>
            #include <openssl/err.h>
            #include <stdio.h>
            #include <stdlib.h>

            void handleErrors(void) {
                unsigned long err;
                while ((err = ERR_get_error()) != 0) {
                    char buf[256];
                    ERR_error_string_n(err, buf, sizeof(buf));
                    fprintf(stderr, "OpenSSL error: %s\n", buf);
                }
                exit(1);
            }

            int main(int argc, char *argv[]) {
                if (argc != 4) {
                    fprintf(stderr, "Usage: %s <privkey.pem> <input file> <output file>\n", argv[0]);
                    return 1;
                }

                char *privkey_filename = argv[1];
                char *input_file = argv[2];
                char *output_file = argv[3];

                FILE *f_input, *f_output, *f_privkey;
                unsigned char buffer[1024];
                unsigned char *plaintext;
                size_t bytes_read, plaintext_len;

                EVP_PKEY *privkey = NULL;
                EVP_PKEY_CTX *ctx = NULL;

                // Load private key
                if (!(f_privkey = fopen(privkey_filename, "r"))) {
                    fprintf(stderr, "Unable to open private key file %s\n", privkey_filename);
                    return 1;
                }

                if (!(privkey = PEM_read_PrivateKey(f_privkey, NULL, NULL, NULL))) {
                    fprintf(stderr, "Error loading private key\n");
                    fclose(f_privkey);
                    handleErrors();
                }
                fclose(f_privkey);

                // Initialise the library
                if (!OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL))
                    handleErrors();

                // Create and initialise the context
                if (!(ctx = EVP_PKEY_CTX_new(privkey, NULL)))
                    handleErrors();

                if (EVP_PKEY_decrypt_init(ctx) <= 0)
                    handleErrors();

                // Open files
                if (!(f_input = fopen(input_file, "rb"))) {
                    fprintf(stderr, "Could not open %s for reading\n", input_file);
                    return 1;
                }

                if (!(f_output = fopen(output_file, "wb"))) {
                    fprintf(stderr, "Could not open %s for writing\n", output_file);
                    return 1;
                }

                // Determine buffer size for output
                if (EVP_PKEY_decrypt(ctx, NULL, &plaintext_len, buffer, sizeof(buffer)) <= 0)
                    handleErrors();
                plaintext = malloc(plaintext_len);
                if (!plaintext) {
                    fprintf(stderr, "Memory allocation failed\n");
                    return 1;
                }

                // Decrypt the data
                while ((bytes_read = fread(buffer, 1, sizeof(buffer), f_input)) > 0) {
                    if (EVP_PKEY_decrypt(ctx, plaintext, &plaintext_len, buffer, bytes_read) <= 0)
                        handleErrors();
                    fwrite(plaintext, 1, plaintext_len, f_output);
                }

                // Clean up
                EVP_PKEY_free(privkey);
                EVP_PKEY_CTX_free(ctx);
                fclose(f_input);
                fclose(f_output);
                free(plaintext);

                printf("Decryption complete.\n");

                return 0;
            }
            ```

            ### 编译指令
            确保在编译时链接 OpenSSL 的加密库：
            ```bash
            gcc sm2_decrypt.c -o sm2_decrypt -lcrypto -lssl
            ```

            ### 使用说明
            运行程序时，确保提供正确的参数：私钥文件、加密的输入文件和要写入的输出文件。如果程序在执行过程中遇到错误，它将打印出 OpenSSL 错误信息，这将帮助你诊断问题。

            如果有任何问题或需要进一步的帮助，请随时告诉我。 

            User: root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# ./sm2_decrypt sm2_private.pem encrypted_file.txt decrypted_file.txt
            OpenSSL error: error:0680007B:asn1 encoding routines::header too long
            OpenSSL error: error:06800066:asn1 encoding routines::bad object header
            OpenSSL error: error:0688010A:asn1 encoding routines::nested asn1 error
            OpenSSL error: error:1A800068:SM2 routines::reason(104) 

            Kimi: 根据您提供的错误信息，这里有几个可能的原因和解决方案：

            1. **ASN.1编码问题**：错误信息表明在处理ASN.1编码时出现了问题，这通常是由于输入文件的格式不正确。确保您的加密文件是使用正确的SM2公钥加密的，并且格式正确。如果您的加密文件是ASN.1编码的，确保它遵循正确的结构。

            2. **密文格式问题**：SM2加密的密文通常包含三部分：C1、C2和C3。C1是椭圆曲线点，C2是密文数据，C3是SM3的摘要值。确保您的加密文件遵循正确的格式。在不同的实现中，C1C2C3和C1C3C2的顺序可能不同，这取决于使用的SM2标准版本。

            3. **密钥不匹配**：确保您使用的私钥与加密时使用的公钥是匹配的。如果密钥不匹配，解密过程将失败。

            4. **OpenSSL版本问题**：如果您使用的OpenSSL版本不支持SM2算法，或者存在某些Bug，可能会导致解密失败。确保您的OpenSSL版本是最新的，或者至少是支持SM2算法的版本。

            5. **代码问题**：如果代码中有错误，比如错误的使用了`EVP_PKEY_decrypt_final`函数，也会导致解密失败。由于`EVP_PKEY_decrypt_final`并不是OpenSSL的标准API，所以在您的代码中应该移除对它的调用。

            6. **内存分配问题**：确保为`plaintext`分配的内存足够大，能够容纳解密后的数据。

            7. **文件读写问题**：确保程序有权限读取输入文件和写入输出文件，并且文件没有损坏。

            8. **使用正确的解密函数**：在OpenSSL中，对于SM2算法，可能需要使用特定的解密函数，而不是通用的`EVP_PKEY_decrypt`。您可能需要查阅OpenSSL的文档，找到正确的函数来使用。

            如果上述解决方案仍然无法解决问题，您可能需要提供更多的上下文信息，例如私钥和加密文件的内容（如果可能的话），以便进一步分析。记住，不要在公共场合或不安全的环境中泄露您的私钥或敏感数据。 

            User: 是不是不能把密文用txt文件保存 

            Kimi: 密文通常可以保存在任何类型的文件中，包括文本文件（.txt）。然而，密文通常是由二进制数据组成的，直接以文本形式保存可能会导致编码问题，特别是如果密文包含无法打印的字符或二进制数据。

            在使用文本文件保存密文时，需要确保在读取和写入时使用正确的模式。例如，在C语言中，应该使用“rb”（读取二进制）和“wb”（写入二进制）模式来处理文件，而不是“r”或“w”，这样可以确保二进制数据被正确处理。

            如果密文是使用SM2算法加密的，并且遵循了正确的ASN.1编码格式，那么在保存和读取时需要特别注意编码和解码的问题。如果密文是以十六进制或Base64编码的字符串形式保存的，那么在解密之前需要先将其转换回原始的二进制形式。

            这里是一个简单的示例，说明如何使用Base64编码和解码来处理二进制数据：

            ```c
            #include <openssl/evp.h>
            #include <openssl/bio.h>
            #include <openssl/buffer.h>

            // 将二进制数据编码为Base64字符串
            char* base64_encode(const unsigned char* buffer, size_t length) {
                BIO *bio, *b64;
                BUF_MEM *bufferPtr;

                b64 = BIO_new(BIO_f_base64());
                bio = BIO_new(BIO_s_mem());
                bio = BIO_push(b64, bio);

                BIO_write(bio, buffer, length);
                BIO_flush(bio);
                BIO_get_mem_ptr(bio, &bufferPtr);

                char *base64text = (char*)malloc(bufferPtr->length);
                memcpy(base64text, bufferPtr->data, bufferPtr->length - 1);
                base64text[bufferPtr->length - 1] = 0;

                BIO_free_all(bio);
                return base64text;
            }

            // 将Base64字符串解码为二进制数据
            unsigned char* base64_decode(const char* b64input, int length, size_t *output_length) {
                BIO *bio, *b64;

                b64 = BIO_new(BIO_f_base64());
                bio = BIO_new_mem_buf(b64input, length);
                bio = BIO_push(b64, bio);

                BUF_MEM *bufferPtr;
                BIO_get_mem_ptr(bio, &bufferPtr);

                unsigned char *buffer = (unsigned char*)malloc(bufferPtr->length);
                BIO_read(bio, buffer, bufferPtr->length);

                *output_length = bufferPtr->length;
                BIO_free_all(bio);
                return buffer;
            }
            ```

            使用这些函数，你可以在保存和读取密文时进行Base64编码和解码，以确保二进制数据的正确处理。记住，无论使用哪种编码方式，都需要在解密之前将编码的密文转换回原始的二进制形式。 

            User: 如何存储sm2加密的密文 

            Kimi: SM2加密的密文存储格式有特定的标准，根据搜索结果，主要有两种格式：

            1. **GM/T0003.4 规定的标准密文格式**：这种格式通常表示为 `C1||C3||C2`（新标准）或 `C1||C2||C3`（旧标准）。其中：
            - `C1` 是随机生成的公钥，格式为 `04||X1||Y1`，其中 `04` 代表未压缩格式，`X1` 和 `Y1` 是椭圆曲线上的点坐标。
            - `C2` 是裸密文，即加密后的字符串。
            - `C3` 是摘要值，计算方式为 `Hash(X2||M||Y2)`，其中 `M` 是原文，`X2`、`Y2` 是用户公钥的坐标。

            2. **GM/T0009 

            User: root@Youer:~/shiyan/shiyan01/shiyan1-2/task01/test_sm2# ./sm2_decrypt sm2_private.pem encrypted_file.bin decrypted_file.bin
            OpenSSL error: error:068000A8:asn1 encoding routines::wrong tag
            OpenSSL error: error:0688010A:asn1 encoding routines::nested asn1 error
            OpenSSL error: error:1A800068:SM2 routines::reason(104) 

            Kimi: 根据您提供的错误信息和搜索结果，出现 "error:068000A8:asn1 encoding routines::wrong tag" 和 "error:1A800068:SM2 routines::reason(104)" 错误的原因可能是：

            1. **密文格式不正确**：密文可能不是使用正确的SM2公钥加密的，或者密文的格式不符合SM2算法的要求。确保加密时使用的是正确的公钥，并且加密过程没有错误。

            2. **ASN.1编码问题**：错误信息表明在处理ASN.1编码时出现了问题，这通常是由于输入文件的格式不正确。如果您的加密文件是ASN.1编码的，确保它遵循正确的结构。

            3. **私钥格式问题**：如果私钥不是PKCS#1或PKCS#8标准格式，可能会导致解密时出现错误。您可能需要将私钥转换为正确的格式。

            4. **OpenSSL版本问题**：如果您使用的OpenSSL版本不支持SM2算法，或者存在某些Bug，可能会导致解密失败。确保您的OpenSSL版本是最新的，或者至少是支持SM2算法的版本。

            5. **密钥不匹配**：确保您使用的私钥与加密时使用的公钥是匹配的。如果密钥不匹配，解密过程将失败。

            6. **文件读写问题**：确保程序有权限读取输入文件和写入输出文件，并且文件没有损坏。

            为了解决这个问题，您可以尝试以下步骤：

            - 确保您的加密文件（`encrypted_file.bin`）是使用正确的SM2公钥加密的，并且格式正确。
            - 确保您的私钥（`sm2_private.pem`）是正确的，并且与用于加密的公钥匹配。
            - 如果您的私钥是PKCS#8格式，您可能需要将其转换为PKCS#1格式，以确保与OpenSSL的兼容性。
            - 确保您的OpenSSL版本支持SM2算法。如果不支持，您可能需要升级OpenSSL或使用其他支持SM2的库。
            - 检查您的文件读写权限，确保程序可以正确读取和写入文件。

            如果问题仍然存在，您可能需要提供更多的上下文信息，例如私钥和加密文件的内容（如果可能的话），以便进一步分析。记住，不要在公共场合或不安全的环境中泄露您的私钥或敏感数据。 

            User: 如何将sm2生成的密文转变ASN.1编码格式 

            Kimi: SM2加密的密文可以转换为ASN.1编码格式，这通常是为了确保密文的格式符合特定的标准或要求。ASN.1（Abstract Syntax Notation One）是一种标准的语法，用于数据结构的描述和编码。在SM2加密中，密文通常由C1、C2、C3三部分组成，其中C1是椭圆曲线点，C2是密文数据，C3是摘要值。

            根据搜索结果，转换SM2密文为ASN.1编码格式通常涉及以下步骤：

            1. **定义ASN.1结构**：首先需要定义一个ASN.1结构来表示SM2密文的C1、C2、C3三部分。这可能需要使用ASN.1的语法来描述这些部分的数据类型和顺序。

            2. **编码密文**：使用ASN.1结构，将C1、C2、C3的数据编码为ASN.1格式。这可能涉及到将原始的二进制数据转换为ASN.1的DER（Distinguished Encoding Rules）或BER（Basic Encoding Rules）编码。

            3. **处理长度和标签**：在ASN.1编码中，每个数据元素都有一个标签来标识其类型，以及一个长度字段来指定数据的大小。确保这些长度和标签被正确处理是转换过程中的关键部分。

            4. **使用工具或库**：有一些工具和库可以帮助进行ASN.1编码和解码，例如OpenSSL、Bouncy Castle等。这些工具通常提供了命令行接口或编程接口，可以用来处理SM2密文的ASN.1编码。

            例如，根据搜索结果中提供的信息，可以通过以下代码示例来实现SM2密文的ASN.1编码转换（摘自 ）：

            ```c
            #include <openssl/ec.h>
            #include <openssl/asn1.h>
            #include <openssl/asn1t.h>

            typedef struct SM2_Ciphertext_st SM2_Ciphertext;
            DECLARE_ASN1_FUNCTIONS(SM2_Ciphertext)

            struct SM2_Ciphertext_st {
                BIGNUM *C1x;
                BIGNUM *C1y;
                ASN1_OCTET_STRING *C3;
                ASN1_OCTET_STRING *C2;
            };

            ASN1_SEQUENCE(SM2_Ciphertext) = {
                ASN1_SIMPLE(SM2_Ciphertext, C1x, BIGNUM),
                ASN1_SIMPLE(SM2_Ciphertext, C1y, BIGNUM),
                ASN1_SIMPLE(SM2_Ciphertext, C3, ASN1_OCTET_STRING),
                ASN1_SIMPLE(SM2_Ciphertext, C2, ASN1_OCTET_STRING),
            } ASN1_SEQUENCE_END(SM2_Ciphertext)

            IMPLEMENT_ASN1_FUNCTIONS(SM2_Ciphertext)

            // 然后使用这些函数来编码和解码SM2密文
            ```

            请注意，这只是一个示例，实际的实现可能需要根据您的具体需求和OpenSSL的版本进行调整。如果您需要进一步的帮助，可以提供更多的上下文信息，例如密文的具体格式和您希望实现的具体功能。 

            User: 在openssl中，如何将sm2生成的密文转变ASN.1编码格式或者确保其生成的就是asn.1的格式 

            Kimi: 在 OpenSSL 中，SM2 加密的密文通常不直接生成 ASN.1 编码格式，但可以转换为 ASN.1 编码格式。ASN.1 (Abstract Syntax Notation One) 是一种标准的语法，用于数据结构的描述和编码。在 SM2 加密中，密文通常由 C1、C2、C3 三部分组成，其中 C1 是椭圆曲线点，C2 是密文数据，C3 是摘要值。

            要将 SM2 生成的密文转换为 ASN.1 编码格式，可以按照以下步骤操作：

            1. **定义 ASN.1 结构**：首先需要定义一个 ASN.1 结构来表示 SM2 密文的 C1、C2、C3 三部分。这可能需要使用 ASN.1 的语法来描述这些部分的数据类型和顺序。

            2. **编码密文**：使用定义的 ASN.1 结构，将 C1、C2、C3 的数据编码为 ASN.1 格式。这可能涉及到将原始的二进制数据转换为 ASN.1 的 DER（Distinguished Encoding Rules）或 BER（Basic Encoding Rules）编码。

            3. **处理长度和标签**：在 ASN.1 编码中，每个数据元素都有一个标签来标识其类型，以及一个长度字段来指定数据的大小。确保这些长度和标签被正确处理是转换过程中的关键部分。

            根据搜索结果，可以通过以下代码示例来实现 SM2 密文的 ASN.1 编码转换 ：

            ```c
            #include <string.h>
            #include <openssl/ec.h>
            #include <openssl/asn1.h>
            #include <openssl/asn1t.h>

            typedef struct SM2_Ciphertext_st SM2_Ciphertext;
            DECLARE_ASN1_FUNCTIONS(SM2_Ciphertext)

            struct SM2_Ciphertext_st {
                BIGNUM *C1x;
                BIGNUM *C1y;
                ASN1_OCTET_STRING *C3;
                ASN1_OCTET_STRING *C2;
            };

            ASN1_SEQUENCE(SM2_Ciphertext) = {
                ASN1_SIMPLE(SM2_Ciphertext, C1x, BIGNUM),
                ASN1_SIMPLE(SM2_Ciphertext, C1y, BIGNUM),
                ASN1_SIMPLE(SM2_Ciphertext, C3, ASN1_OCTET_STRING),
                ASN1_SIMPLE(SM2_Ciphertext, C2, ASN1_OCTET_STRING),
            } ASN1_SEQUENCE_END(SM2_Ciphertext)

            IMPLEMENT_ASN1_FUNCTIONS(SM2_Ciphertext)

            // 然后使用这些函数来编码和解码 SM2 密文
            ```

            在实际应用中，您可能需要根据具体的加密数据和需求来调整上述代码。这可能包括处理不同的密文长度、添加错误检查和处理以及其他必要的调整。如果您需要进一步的帮助，可以提供更多的上下文信息，例如密文的具体格式和您希望实现的具体功能。 

            User: 请帮我编写一个调用openssl库且从命令行接受密钥和加解密文件的SM2解密函数 

            Kimi: 下面是一个使用 OpenSSL 库的示例 C 程序，它从命令行接受私钥文件、加密文件（密文）和输出文件（明文）路径，并执行 SM2 解密操作。请注意，这个示例假设你已经有了一个正确格式的 SM2 密文文件，并且你的 OpenSSL 库已经支持 SM2。

            ```c
            #include <openssl/ec.h>
            #include <openssl/objects.h>
            #include <openssl/evp.h>
            #include <openssl/err.h>
            #include <openssl/pem.h>
            #include <stdio.h>
            #include <stdlib.h>

            void handle_errors() {
                ERR_print_errors_fp(stderr);
                abort();
            }

            int main(int argc, char **argv) {
                if (argc != 4) {
                    fprintf(stderr, "Usage: %s <private_key.pem> <encrypted_file> <decrypted_file>\n", argv[0]);
                    return EXIT_FAILURE;
                }

                const char *private_key_file = argv[1];
                const char *encrypted_file = argv[2];
                const char *decrypted_file = argv[3];

                // Load private key
                EVP_PKEY *private_key = NULL;
                FILE *fp;
                fp = fopen(private_key_file, "r");
                if (!fp) {
                    perror("Error opening private key file");
                    return EXIT_FAILURE;
                }
                private_key = PEM_read_PrivateKey(fp, NULL, NULL, NULL);
                fclose(fp);
                if (!private_key) {
                    handle_errors();
                    return EXIT_FAILURE;
                }

                // Setup decryption
                EVP_PKEY_CTX *ctx = EVP_PKEY_CTX_new(private_key, NULL);
                if (!ctx) {
                    handle_errors();
                    return EXIT_FAILURE;
                }
                if (EVP_PKEY_decrypt_init(ctx) <= 0) {
                    handle_errors();
                    return EXIT_FAILURE;
                }

                // Read encrypted data
                FILE *fin = fopen(encrypted_file, "rb");
                if (!fin) {
                    perror("Error opening encrypted file");
                    return EXIT_FAILURE;
                }
                // Determine the size of the encrypted data
                fseek(fin, 0, SEEK_END);
                long encrypted_data_size = ftell(fin);
                fseek(fin, 0, SEEK_SET);
                unsigned char *encrypted_data = malloc(encrypted_data_size);
                fread(encrypted_data, 1, encrypted_data_size, fin);
                fclose(fin);

                // Decrypt data
                unsigned char *decrypted_data = NULL;
                size_t decrypted_data_size = 0;
                if (EVP_PKEY_decrypt(ctx, NULL, &decrypted_data_size, encrypted_data, encrypted_data_size) <= 0) {
                    handle_errors();
                    return EXIT_FAILURE;
                }
                decrypted_data = malloc(decrypted_data_size);
                if (EVP_PKEY_decrypt(ctx, decrypted_data, &decrypted_data_size, encrypted_data, encrypted_data_size) <= 0) {
                    handle_errors();
                    return EXIT_FAILURE;
                }

                // Write decrypted data to file
                FILE *fout = fopen(decrypted_file, "wb");
                if (!fout) {
                    perror("Error opening decrypted file");
                    return EXIT_FAILURE;
                }
                fwrite(decrypted_data, 1, decrypted_data_size, fout);
                fclose(fout);

                // Clean up
                EVP_PKEY_CTX_free(ctx);
                EVP_PKEY_free(private_key);
                free(encrypted_data);
                free(decrypted_data);

                printf("Decryption successful.\n");
                return EXIT_SUCCESS;
            }
            ```

            编译这个程序时，确保链接了 OpenSSL 的加密库：

            ```bash
            gcc -o sm2_decrypt sm2_decrypt.c -lcrypto -lssl
            ```

            运行程序时，使用以下命令格式：

            ```bash
            ./sm2_decrypt private_key.pem encrypted_file encrypted_file_out
            ```

            其中 `private_key.pem` 是你的 SM2 私钥文件，`encrypted_file` 是包含 SM2 加密数据的文件，`encrypted_file_out` 是你希望写入解密数据的输出文件。

            请注意，这个示例代码假设你的 OpenSSL 库已经支持 SM2 算法，并且你有一个正确格式的 SM2 密文文件。如果你的 OpenSSL 版本不支持 SM2，你可能需要使用其他库或更新你的 OpenSSL 版本。 


            ```
    - [这一问题的具体解释（AI）](https://kimi.moonshot.cn/share/cs74alcjot6ji2ba357g)
        ```
        User: 代码1：
                #include <openssl/evp.h>
                #include <openssl/pem.h>
                #include <stdio.h>
                #include <stdlib.h>

                void handleErrors(void) {
                    fprintf(stderr, "An error occurred.\n");
                    exit(1);
                }

                int main(int argc, char *argv[]) {
                    if (argc != 4) {
                        fprintf(stderr, "Usage: %s <privkey.pem> <input file> <output file>\n", argv[0]);
                        return 1;
                    }

                    char *privkey_filename = argv[1];
                    char *input_file = argv[2];
                    char *output_file = argv[3];

                    FILE *f_input, *f_output, *f_privkey;
                    unsigned char buffer[1024];
                    unsigned char *plaintext;
                    size_t plaintext_len;
                    size_t bytes_read;  // 声明 bytes_read 变量

                    EVP_PKEY *privkey = NULL;
                    EVP_PKEY_CTX *ctx = NULL;

                    // Load private key
                    if (!(f_privkey = fopen(privkey_filename, "r"))) {
                        fprintf(stderr, "Unable to open private key file %s\n", privkey_filename);
                        return 1;
                    }

                    if (!(privkey = PEM_read_PrivateKey(f_privkey, NULL, NULL, NULL))) {
                        fprintf(stderr, "Error loading private key\n");
                        fclose(f_privkey);
                        return 1;
                    }
                    fclose(f_privkey);

                    // Initialise the library
                    if (!OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL))
                        handleErrors();

                    // Create and initialise the context
                    if (!(ctx = EVP_PKEY_CTX_new(privkey, NULL)))
                        handleErrors();

                    if (EVP_PKEY_decrypt_init(ctx) <= 0)
                        handleErrors();

                    // Open files
                    if (!(f_input = fopen(input_file, "rb"))) {
                        fprintf(stderr, "Could not open %s for reading\n", input_file);
                        return 1;
                    }

                    if (!(f_output = fopen(output_file, "wb"))) {
                        fprintf(stderr, "Could not open %s for writing\n", output_file);
                        return 1;
                    }

                    // Determine buffer size for output
                    if (EVP_PKEY_decrypt(ctx, NULL, &plaintext_len, buffer, sizeof(buffer)) <= 0)
                        handleErrors();
                    plaintext = malloc(plaintext_len);

                    // Decrypt the data
                    while ((bytes_read = fread(buffer, 1, sizeof(buffer), f_input)) > 0) {
                        if (EVP_PKEY_decrypt(ctx, plaintext, &plaintext_len, buffer, bytes_read) <= 0)
                            handleErrors();
                        fwrite(plaintext, 1, plaintext_len, f_output);
                    }

                    // Clean up
                    EVP_PKEY_free(privkey);
                    EVP_PKEY_CTX_free(ctx);
                    fclose(f_input);
                    fclose(f_output);
                    free(plaintext);

                    printf("Decryption complete.\n");

                    return 0;
                }
        代码2：
                        #include <openssl/ec.h>
                        #include <openssl/objects.h>
                        #include <openssl/evp.h>
                        #include <openssl/err.h>
                        #include <openssl/pem.h>
                        #include <stdio.h>
                        #include <stdlib.h>

                        void handle_errors() {
                            ERR_print_errors_fp(stderr);
                            abort();
                        }

                        int main(int argc, char **argv) {
                            if (argc != 4) {
                                fprintf(stderr, "Usage: %s <private_key.pem> <encrypted_file> <decrypted_file>\n", argv[0]);
                                return EXIT_FAILURE;
                            }

                            const char *private_key_file = argv[1];
                            const char *encrypted_file = argv[2];
                            const char *decrypted_file = argv[3];

                            // Load private key
                            EVP_PKEY *private_key = NULL;
                            FILE *fp;
                            fp = fopen(private_key_file, "r");
                            if (!fp) {
                                perror("Error opening private key file");
                                return EXIT_FAILURE;
                            }
                            private_key = PEM_read_PrivateKey(fp, NULL, NULL, NULL);
                            fclose(fp);
                            if (!private_key) {
                                handle_errors();
                                return EXIT_FAILURE;
                            }

                            // Setup decryption
                            EVP_PKEY_CTX *ctx = EVP_PKEY_CTX_new(private_key, NULL);
                            if (!ctx) {
                                handle_errors();
                                return EXIT_FAILURE;
                            }
                            if (EVP_PKEY_decrypt_init(ctx) <= 0) {
                                handle_errors();
                                return EXIT_FAILURE;
                            }

                            // Read encrypted data
                            FILE *fin = fopen(encrypted_file, "rb");
                            if (!fin) {
                                perror("Error opening encrypted file");
                                return EXIT_FAILURE;
                            }
                            // Determine the size of the encrypted data
                            fseek(fin, 0, SEEK_END);
                            long encrypted_data_size = ftell(fin);
                            fseek(fin, 0, SEEK_SET);
                            unsigned char *encrypted_data = malloc(encrypted_data_size);
                            fread(encrypted_data, 1, encrypted_data_size, fin);
                            fclose(fin);

                            // Decrypt data
                            unsigned char *decrypted_data = NULL;
                            size_t decrypted_data_size = 0;
                            if (EVP_PKEY_decrypt(ctx, NULL, &decrypted_data_size, encrypted_data, encrypted_data_size) <= 0) {
                                handle_errors();
                                return EXIT_FAILURE;
                            }
                            decrypted_data = malloc(decrypted_data_size);
                            if (EVP_PKEY_decrypt(ctx, decrypted_data, &decrypted_data_size, encrypted_data, encrypted_data_size) <= 0) {
                                handle_errors();
                                return EXIT_FAILURE;
                            }

                            // Write decrypted data to file
                            FILE *fout = fopen(decrypted_file, "wb");
                            if (!fout) {
                                perror("Error opening decrypted file");
                                return EXIT_FAILURE;
                            }
                            fwrite(decrypted_data, 1, decrypted_data_size, fout);
                            fclose(fout);

                            // Clean up
                            EVP_PKEY_CTX_free(ctx);
                            EVP_PKEY_free(private_key);
                            free(encrypted_data);
                            free(decrypted_data);

                            printf("Decryption successful.\n");
                            return EXIT_SUCCESS;
                        }
        请你分析为什么第一个代码会有文件格式（ASN.1）的报错而第二个代码是正确的 

        Kimi: 两个代码都旨在使用OpenSSL库进行解密操作，但是它们在处理输入数据和调用解密函数的方式上有所不同。以下是可能导致第一个代码出现ASN.1格式错误的原因，以及第二个代码为何能够正确执行的分析：

        1. **一次性读取与分块读取**：
        - 第一个代码尝试分块读取加密数据，每次读取固定大小的缓冲区（`buffer`），然后对每个缓冲区进行解密。这种方法在理论上是可行的，但前提是加密数据的块边界能够正确对齐。如果加密数据的块边界没有正确对齐，可能会导致ASN.1格式错误，因为ASN.1编码的数据结构可能被错误地分割。
        - 第二个代码一次性读取整个加密文件到内存中，然后一次性进行解密。这种方法更可靠，因为它确保了整个加密数据作为一个整体被处理，避免了块边界对齐的问题。

        2. **输出缓冲区大小的确定**：
        - 在第一个代码中，`plaintext_len`是在第一次调用`EVP_PKEY_decrypt`时确定的，但是这个调用并没有传入实际的加密数据（`buffer`），这可能导致`plaintext_len`的值不准确。此外，如果加密数据的块边界没有正确对齐，每次解密操作可能需要不同的输出缓冲区大小。
        - 在第二个代码中，`decrypted_data_size`是在第一次调用`EVP_PKEY_decrypt`时确定的，这次调用传入了整个加密数据。这确保了输出缓冲区大小的准确性，因为整个加密数据作为一个整体被处理。

        3. **错误处理**：
        - 第一个代码在出现错误时调用`handleErrors`函数，该函数只是打印一条错误消息并退出程序，没有提供详细的错误信息。
        - 第二个代码在出现错误时调用`handle_errors`函数，该函数使用`ERR_print_errors_fp`函数打印详细的错误信息，这有助于诊断问题。

        4. **内存分配**：
        - 在第一个代码中，`plaintext`的内存分配是基于第一次调用`EVP_PKEY_decrypt`时返回的`plaintext_len`，这可能不准确，如前所述。
        - 在第二个代码中，`decrypted_data`的内存分配是基于第一次调用`EVP_PKEY_decrypt`时返回的`decrypted_data_size`，这更可靠，因为它是基于整个加密数据的。

        综上所述，第一个代码可能出现ASN.1格式错误的原因可能是由于分块读取加密数据导致的块边界对齐问题，以及输出缓冲区大小的确定不准确。第二个代码通过一次性读取和处理整个加密数据，避免了这些问题，因此能够正确执行解密操作。 


        ```
    - 反思：
        - 关键在于明确根本问题，之前尝试解决时猜测了很多解决思路，比如转换密文格式等，但这些只是猜测，最终浪费了自己的时间
            - 这就是[“XY”问题的翻版](https://coolshell.cn/articles/10804.html)
        - 同时不要就一个代码问AI太久，AI跳不出原有的框架，就会一直给出错误代码。及时开启新对话。
        - [以及加解密存储的文件还是保存为.bin比较好，不容易有格式错误](https://www.doubao.com/thread/w285625c71c9a0786)

- openssl调用sm2时一般要用evp接口，不能直接调用

- 私钥格式问题
    - 这次遇到了哪些格式
        - PEM格式(EC格式)
        - PKCS#8格式
    - 不同函数对私钥格式支持不一样，即sm2_private_key_from_pem（支持PKCS#8格式）和sm2_private_key_info_from_pem（支持EC格式/PEM格式）
    - AI的协助：
        - 我的提问
            ```
            请参考下面的私钥加载过程修改之后的签名生成程序：
            私钥加载过程：
            // Load private key
            SM2_KEY sm2_key;
            FILE *fp = fopen(private_key_file, "r");
            if (!fp) {
            perror("Failed to open private key file");
            return 1;
            }

            // 使用 PEM 格式加载私钥
            if (sm2_private_key_info_from_pem(&sm2_key, fp) != 1) {
                fprintf(stderr, "Failed to read private key from PEM\n");
                fclose(fp);
                return 1;
            }
            fclose(fp);
            签名程序：
            #include <stdio.h>
            #include <stdlib.h>
            #include <string.h>
            #include <gmssl/sm2.h>
            #include <gmssl/pem.h>
            #include <gmssl/error.h>
            #include <gmssl/sm3.h>

            int main(int argc, char **argv)
            {
            if (argc != 4) {
            printf("Usage: %s <private_key.pem> <input.txt> <signature.sig>\n", argv[0]);
            return 1;
            }

            const char *private_key_file = argv[1];
            const char *input_file = argv[2];
            const char *signature_file = argv[3];

            SM2_KEY sm2_key;
            FILE *key_fp = NULL;
            FILE *input_fp = NULL;
            FILE *sig_fp = NULL;
            unsigned char dgst[32];
            unsigned char sig[SM2_MAX_SIGNATURE_SIZE];
            size_t siglen;
            unsigned char buffer[1024];
            size_t len;

            // 读取私钥
            if (!(key_fp = fopen(private_key_file, "r"))) {
                fprintf(stderr, "Error opening private key file: %s\n", private_key_file);
                return 1;
            }

            if (sm2_private_key_from_pem(&sm2_key, key_fp) != 1) {
                fprintf(stderr, "Error loading private key from PEM file: %s\n", private_key_file);
                fclose(key_fp);
                return 1;
            }
            fclose(key_fp);

            // 读取输入文件并计算SM3哈希
            if (!(input_fp = fopen(input_file, "r"))) {
                fprintf(stderr, "Error opening input file: %s\n", input_file);
                return 1;
            }

            SM3_CTX sm3_ctx;
            sm3_init(&sm3_ctx);

            while ((len = fread(buffer, 1, sizeof(buffer), input_fp)) > 0) {
                sm3_update(&sm3_ctx, buffer, len);
            }
            fclose(input_fp);

            sm3_finish(&sm3_ctx, dgst);

            // 生成签名
            siglen = sizeof(sig);  // 确保我们为签名的大小传递正确的变量
            if (sm2_sign(&sm2_key, dgst, sig, &siglen) != 1) {
                fprintf(stderr, "Error generating SM2 signature\n");
                return 1;
            }

            // 写入签名到文件
            if (!(sig_fp = fopen(signature_file, "wb"))) {
                fprintf(stderr, "Error opening signature file: %s\n", signature_file);
                return 1;
            }

            if (fwrite(sig, 1, siglen, sig_fp) != siglen) {
                fprintf(stderr, "Error writing signature to file: %s\n", signature_file);
                fclose(sig_fp);
                return 1;
            }
            fclose(sig_fp);

            printf("Signature generated and saved to %s\n", signature_file);
            return 0;
            }
            ```
        - AI的回答：
            ```
            您提供的代码中有一个私钥加载过程和一个签名生成程序。为了将私钥加载过程合并到签名生成程序中，我们需要替换原有的私钥加载部分，以使用您提供的加载过程。这是一个经过修改的完整签名生成程序，使用了新的私钥加载逻辑。
            修改后的签名生成程序
            #include &lt;stdio.h&gt;
            #include &lt;stdlib.h&gt;
            #include &lt;string.h&gt;
            #include &lt;gmssl/sm2.h&gt;
            #include &lt;gmssl/pem.h&gt;
            #include &lt;gmssl/error.h&gt;
            #include &lt;gmssl/sm3.h&gt;

            int main(int argc, char **argv)
            {
                if (argc != 4) {
                    printf("Usage: %s &lt;private_key.pem&gt; &lt;input.txt&gt; &lt;signature.sig&gt;\n", argv[0]);
                    return 1;
                }

                const char *private_key_file = argv[1];
                const char *input_file = argv[2];
                const char *signature_file = argv[3];

                SM2_KEY sm2_key;
                FILE *key_fp = NULL;
                FILE *input_fp = NULL;
                FILE *sig_fp = NULL;
                unsigned char dgst[32];
                unsigned char sig[SM2_MAX_SIGNATURE_SIZE];
                size_t siglen;
                unsigned char buffer[1024];
                size_t len;

                // 加载私钥
                key_fp = fopen(private_key_file, "r");
                if (!key_fp) {
                    perror("Failed to open private key file");
                    return 1;
                }

                // 使用 PEM 格式加载私钥
                if (sm2_private_key_info_from_pem(&amp;sm2_key, key_fp) != 1) {
                    fprintf(stderr, "Failed to read private key from PEM\n");
                    fclose(key_fp);
                    return 1;
                }
                fclose(key_fp);

                // 读取输入文件并计算SM3哈希
                input_fp = fopen(input_file, "r");
                if (!input_fp) {
                    fprintf(stderr, "Error opening input file: %s\n", input_file);
                    return 1;
                }

                SM3_CTX sm3_ctx;
                sm3_init(&amp;sm3_ctx);

                while ((len = fread(buffer, 1, sizeof(buffer), input_fp)) &gt; 0) {
                    sm3_update(&amp;sm3_ctx, buffer, len);
                }
                fclose(input_fp);

                sm3_finish(&amp;sm3_ctx, dgst);

                // 生成签名
                siglen = sizeof(sig);  // 确保我们为签名的大小传递正确的变量
                if (sm2_sign(&amp;sm2_key, dgst, sig, &amp;siglen) != 1) {
                    fprintf(stderr, "Error generating SM2 signature\n");
                    return 1;
                }

                // 写入签名到文件
                sig_fp = fopen(signature_file, "wb");
                if (!sig_fp) {
                    fprintf(stderr, "Error opening signature file: %s\n", signature_file);
                    return 1;
                }

                if (fwrite(sig, 1, siglen, sig_fp) != siglen) {
                    fprintf(stderr, "Error writing signature to file: %s\n", signature_file);
                    fclose(sig_fp);
                    return 1;
                }
                fclose(sig_fp);

                printf("Signature generated and saved to %s\n", signature_file);
                return 0;
            }

            修改的要点

            1.私钥加载逻辑：


            2.使用提供的私钥加载过程替换了原有的 sm2_private_key_from_pem 函数调用。
            3.采用了 sm2_private_key_info_from_pem 来从 PEM 文件中加载私钥。


            4.错误处理：


            5.在每个打开文件和加载私钥的步骤中增加了适当的错误处理，确保在出现错误时能够输出相应的信息并退出程序。


            6.变量和文件指针管理：


            7.确保在所有文件操作后关闭文件指针，防止资源泄漏。

            注意事项

            8.请确保您拥有所需的库和头文件（如 gmssl）以支持 SM2 签名和 SM3 哈希计算。
            9.在实际使用中，请根据您的需求调整输入输出文件的路径和名称。

            ```
    - [原理解答(AI)](https://www.doubao.com/thread/wac4b5b95ff1e8b8b)
    - 反思：
        - 提问时要学会借鉴成功经验。
        - 比如在这里，我之前的sm2加解密就可以使用PKCS#8格式的私钥，那么就可以参考他们的代码去实现或者给AI这方面的提示

